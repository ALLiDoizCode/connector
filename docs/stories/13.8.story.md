<!-- Powered by BMAD™ Core -->

# Story 13.8: Integration Tests

## Status

Done

## Story

**As a** connector developer,
**I want** end-to-end integration tests for multi-agent communication,
**So that** I can verify the complete Agent Society Protocol works correctly across multiple agents with TOON-serialized events, payment flows, follow graph routing, rejection codes, and settlement.

## Acceptance Criteria

1. Agent A queries Agent B's database
2. Payment flows correctly between agents
3. Events propagate through follow graph
4. Rejection codes returned for errors
5. Settlement triggers after threshold

## Tasks / Subtasks

- [x] Task 1: Create Test Infrastructure and Fixtures (AC: 1-5)
  - [x] Create file: `packages/connector/test/integration/agent-multi-agent.test.ts`
  - [x] Define test constants:
    ```typescript
    const AGENT_A_PRIVKEY = 'a'.repeat(64); // Test agent A
    const AGENT_B_PRIVKEY = 'b'.repeat(64); // Test agent B
    const AGENT_C_PRIVKEY = 'c'.repeat(64); // Test agent C (for multi-hop)
    ```
  - [x] Mock TOON codec for test environment (ESM compatibility)
  - [x] [Source: packages/connector/test/integration/agent-config-integration.test.ts patterns]

- [x] Task 2: Create Test Helpers Module (AC: 1-5)
  - [x] Create directory: `packages/connector/test/integration/helpers/` (if not exists)
  - [x] Create file: `packages/connector/test/integration/helpers/agent-test-helpers.ts`
  - [x] Add imports using explicit paths (matching existing test patterns):
    ```typescript
    import { AgentNode } from '../../../src/agent/agent-node';
    import type { AgentNodeConfig, AgentTelemetryEvent } from '../../../src/agent/agent-node';
    import { ToonCodec } from '../../../src/agent/toon-codec';
    import type { NostrEvent } from '../../../src/agent/toon-codec';
    import { ILPPreparePacket, PacketType, ILPErrorCode } from '@m2m/shared';
    import { getPublicKey, finalizeEvent } from 'nostr-tools';
    ```
  - [x] Implement helper functions:
    ```typescript
    export function createTestNostrEvent(overrides?: Partial<NostrEvent>): NostrEvent;
    export function createTestILPPreparePacket(
      event: NostrEvent,
      amount: bigint,
      destination: string
    ): ILPPreparePacket;
    export function createTestAgentConfig(overrides?: Partial<AgentNodeConfig>): AgentNodeConfig;
    export async function createInitializedAgent(
      config?: Partial<AgentNodeConfig>
    ): Promise<AgentNode>;
    export function signNostrEvent(event: NostrEvent, privkey: string): NostrEvent;
    ```
  - [x] Export helpers from main test file or import directly
  - [x] [Source: packages/connector/test/integration/agent-config-integration.test.ts helper patterns]

- [x] Task 3: Implement Two-Agent Communication Test Setup (AC: 1, 2, 4)
  - [x] Create `describe('Two-Agent Communication')` test suite
  - [x] In `beforeEach`:
    - [x] Create Agent A with in-memory database (`:memory:`)
    - [x] Create Agent B with in-memory database (`:memory:`)
    - [x] Initialize both agents: `await agentA.initialize()`, `await agentB.initialize()`
    - [x] Configure Agent A to follow Agent B with ILP address `g.agent.b`
  - [x] In `afterEach`:
    - [x] Shutdown both agents: `await agentA.shutdown()`, `await agentB.shutdown()`
  - [x] [Source: packages/connector/test/integration/agent-config-integration.test.ts lines 32-50]

- [x] Task 4: Test Agent A Queries Agent B's Database (AC: 1)
  - [x] Create test: `it('should query Agent B database and receive results')`
  - [x] Test flow:

    ```typescript
    // 1. Store a note event in Agent B's database directly
    await agentB.database.storeEvent(testNoteEvent);

    // 2. Create Kind 10000 query event from Agent A
    const queryEvent = createTestEvent({
      kind: 10000,
      pubkey: getPublicKey(AGENT_A_PRIVKEY),
      content: JSON.stringify({ kinds: [1] }), // Query all Kind 1 events
    });

    // 3. Create ILP Prepare packet with query event
    const packet = createTestPreparePacket(queryEvent, 200n, 'g.agent.b.query');

    // 4. Process packet through Agent B
    const response = await agentB.processIncomingPacket(packet, 'agent-a');

    // 5. Verify Fulfill with query results
    expect(response.type).toBe(PacketType.FULFILL);
    if (response.type === PacketType.FULFILL) {
      const events = toonCodec.decodeMany(response.data);
      expect(events).toHaveLength(1);
      expect(events[0].id).toBe(testNoteEvent.id);
    }
    ```

  - [x] [Source: packages/connector/src/agent/handlers/query-handler.ts, docs/prd/epic-13-agent-society-protocol.md line 330]

- [x] Task 5: Test Payment Validation (AC: 2)
  - [x] Create test: `it('should fulfill when payment is sufficient')`
    - [x] Send Kind 1 note with `amount: 100n` (equal to pricing.noteStorage)
    - [x] Verify Fulfill response
  - [x] Create test: `it('should reject when payment is insufficient')`
    - [x] Send Kind 1 note with `amount: 50n` (below pricing.noteStorage of 100n)
    - [x] Verify Reject response with code F03_INVALID_AMOUNT
    - [x] Verify error message indicates required vs provided amount
  - [x] Create test: `it('should accept zero payment for free tier services')`
    - [x] Configure agent with `pricing.noteStorage: 0n`
    - [x] Send Kind 1 note with `amount: 0n`
    - [x] Verify Fulfill response
  - [x] [Source: packages/connector/src/agent/event-handler.ts payment validation, docs/prd/epic-13-agent-society-protocol.md lines 128-134]

- [x] Task 6: Test Event Propagation Through Follow Graph (AC: 3)
  - [x] Create test: `it('should route events through follow graph')`
  - [x] Test flow:

    ```typescript
    // Setup: A follows B, B follows C
    // A → B → C topology

    // Configure follows
    agentA.followGraphRouter.addFollow({
      pubkey: getPublicKey(AGENT_B_PRIVKEY),
      ilpAddress: 'g.agent.b',
    });
    agentB.followGraphRouter.addFollow({
      pubkey: getPublicKey(AGENT_C_PRIVKEY),
      ilpAddress: 'g.agent.c',
    });

    // Create event destined for Agent C
    const event = createTestEvent({ kind: 1 });
    const packet = createTestPreparePacket(event, 100n, 'g.agent.c');

    // Verify routing lookups work
    expect(agentA.followGraphRouter.hasRouteTo('g.agent.b')).toBe(true);
    expect(agentB.followGraphRouter.hasRouteTo('g.agent.c')).toBe(true);
    expect(agentB.followGraphRouter.getNextHop('g.agent.c')).toBe(getPublicKey(AGENT_C_PRIVKEY));
    ```

  - [x] Create test: `it('should return F02 for unreachable destination')`
    - [x] Send event to address not in follow graph: `g.agent.unknown`
    - [x] Verify routing table returns no route
  - [x] [Source: packages/connector/src/agent/follow-graph-router.ts, docs/prd/epic-13-agent-society-protocol.md lines 117-121]

- [x] Task 7: Test Rejection Codes for Error Scenarios (AC: 4)
  - [x] Create test: `it('should return F01 for malformed TOON data')`
    - [x] Send packet with invalid data (not TOON encoded)
    - [x] Verify Reject with code F01_INVALID_PACKET
  - [x] Create test: `it('should return F03 for insufficient payment')`
    - [x] Send valid event with payment below required
    - [x] Verify Reject with code F03_INVALID_AMOUNT
  - [x] Create test: `it('should return F99 for unsupported event kind')`
    - [x] Send event with unregistered kind (e.g., Kind 9999)
    - [x] Verify Reject with code F99_APPLICATION_ERROR
  - [x] Create test: `it('should return T00 for internal errors')`
    - [x] Simulate database error by closing database then processing packet
    - [x] Verify Reject with code T00_INTERNAL_ERROR
  - [x] Create test: `it('should return T00 when agent not initialized')`
    - [x] Create agent but don't call initialize()
    - [x] Send packet
    - [x] Verify Reject with code T00_INTERNAL_ERROR and message 'Agent not initialized'
  - [x] [Source: docs/prd/epic-13-agent-society-protocol.md lines 146-154, packages/connector/src/agent/agent-node.ts error mapping]

- [x] Task 8: Test Settlement Threshold Detection (AC: 5)
  - [x] Create test: `it('should accumulate balance and detect settlement threshold')`
  - [x] **Note:** This test verifies AgentNode's role in the settlement flow
  - [x] **Settlement Integration Boundary:**
    - AgentNode returns Fulfill packets (payment accepted at protocol level)
    - Balance tracking occurs in TigerBeetle (separate integration)
    - SettlementMonitor triggers settlement when threshold reached
    - This test verifies the AgentNode portion: successful Fulfills = accumulated value
  - [ ] Test approach:

    ```typescript
    // Create multiple successful transactions
    for (let i = 0; i < 10; i++) {
      const event = createTestEvent({ kind: 1, content: `Note ${i}` });
      const packet = createTestPreparePacket(event, 100n, 'g.agent.b');
      const response = await agentB.processIncomingPacket(packet, 'agent-a');
      expect(response.type).toBe(PacketType.FULFILL);
    }

    // Verify 10 events stored (represents 1000n total value accepted)
    const storedEvents = await agentB.database.queryEvents({ kinds: [1] });
    expect(storedEvents).toHaveLength(10);

    // Verify telemetry shows 10 successful AGENT_EVENT_HANDLED events
    // (Telemetry can be used by SettlementMonitor to track value flow)
    expect(
      telemetryEvents.filter((e) => e.type === 'AGENT_EVENT_HANDLED' && e.success)
    ).toHaveLength(10);
    ```

  - [x] **Verification points for settlement integration:**
    - All 10 packets return Fulfill (not Reject)
    - Each Fulfill represents `amount` accepted (100n × 10 = 1000n total)
    - Database confirms events stored (work completed)
    - Telemetry emitted for each successful event (observable by SettlementMonitor)
  - [x] Reference existing settlement integration tests for full settlement flow
  - [x] [Source: packages/connector/test/integration/settlement-threshold-detection.test.ts patterns, docs/architecture/test-strategy-and-standards.md lines 65-133]

- [x] Task 9: Test Kind 3 Follow Event Processing (AC: 3)
  - [x] Create test: `it('should update routing table from Kind 3 event')`
  - [x] Test flow:

    ```typescript
    // Create Kind 3 follow event with ILP address tags
    const followEvent = createTestEvent({
      kind: 3,
      pubkey: getPublicKey(AGENT_A_PRIVKEY),
      tags: [
        ['p', getPublicKey(AGENT_B_PRIVKEY), '', 'bob'],
        ['ilp', getPublicKey(AGENT_B_PRIVKEY), 'g.agent.bob.query'],
      ],
    });

    // Process as ILP packet
    const packet = createTestPreparePacket(followEvent, 50n, 'g.agent.a');
    const response = await agentA.processIncomingPacket(packet, 'external');

    // Verify routing table updated
    expect(response.type).toBe(PacketType.FULFILL);
    expect(agentA.followGraphRouter.hasRouteTo('g.agent.bob.query')).toBe(true);
    ```

  - [x] [Source: packages/connector/src/agent/handlers/follow-handler.ts, docs/prd/epic-13-agent-society-protocol.md lines 104-114]

- [x] Task 10: Test Kind 5 Delete Event Processing (AC: 1)
  - [x] Create test: `it('should delete events when authorized')`
  - [x] Test flow:

    ```typescript
    // Store an event first
    const noteEvent = createTestEvent({ kind: 1 });
    await agentA.database.storeEvent(noteEvent);

    // Create delete request from same author
    const deleteEvent = createTestEvent({
      kind: 5,
      pubkey: noteEvent.pubkey, // Same author
      tags: [['e', noteEvent.id]],
    });

    // Process delete request
    const packet = createTestPreparePacket(deleteEvent, 10n, 'g.agent.a');
    const response = await agentA.processIncomingPacket(packet, 'external');

    // Verify deletion
    expect(response.type).toBe(PacketType.FULFILL);
    const remaining = await agentA.database.queryEvents({ ids: [noteEvent.id] });
    expect(remaining).toHaveLength(0);
    ```

  - [x] Create test: `it('should reject unauthorized deletion attempts')`
    - [x] Store event from Author A
    - [x] Send delete request from Author B
    - [x] Verify event NOT deleted (authorization check)
  - [x] [Source: packages/connector/src/agent/handlers/delete-handler.ts, NIP-09 authorization]

- [x] Task 11: Test Telemetry Event Emission (AC: 1-5)
  - [x] Create test: `it('should emit telemetry events during packet processing')`
  - [x] Test flow:

    ```typescript
    // Capture telemetry events
    const telemetryEvents: AgentTelemetryEvent[] = [];
    agentB.onTelemetry = (event) => telemetryEvents.push(event);

    // Process a packet
    const event = createTestEvent({ kind: 1 });
    const packet = createTestPreparePacket(event, 100n, 'g.agent.b');
    await agentB.processIncomingPacket(packet, 'agent-a');

    // Verify telemetry emitted
    expect(telemetryEvents).toContainEqual(
      expect.objectContaining({
        type: 'AGENT_EVENT_RECEIVED',
        eventKind: 1,
      })
    );
    expect(telemetryEvents).toContainEqual(
      expect.objectContaining({
        type: 'AGENT_EVENT_HANDLED',
        success: true,
      })
    );
    ```

  - [x] [Source: packages/connector/src/agent/agent-node.ts telemetry emission]

- [x] Task 12: Test Subscription Matching and Push (AC: 3)
  - [x] Create test: `it('should match events to active subscriptions')`
  - [x] Test flow:

    ```typescript
    // Register a subscription on Agent B
    agentB.subscriptionManager.registerSubscription('agent-a', 'sub-1', {
      kinds: [1],
      authors: [getPublicKey(AGENT_A_PRIVKEY)],
    });

    // Store an event that matches the subscription
    const noteEvent = createTestEvent({
      kind: 1,
      pubkey: getPublicKey(AGENT_A_PRIVKEY),
    });
    const packet = createTestPreparePacket(noteEvent, 100n, 'g.agent.b');
    await agentB.processIncomingPacket(packet, 'agent-a');

    // Verify subscription push telemetry (actual BTP push not tested at AgentNode level)
    const telemetryEvents: AgentTelemetryEvent[] = [];
    agentB.onTelemetry = (event) => telemetryEvents.push(event);

    // Process another matching event
    const noteEvent2 = createTestEvent({
      kind: 1,
      pubkey: getPublicKey(AGENT_A_PRIVKEY),
      content: 'Second note',
    });
    const packet2 = createTestPreparePacket(noteEvent2, 100n, 'g.agent.b');
    await agentB.processIncomingPacket(packet2, 'agent-a');

    // Check that subscription match was detected
    expect(telemetryEvents).toContainEqual(
      expect.objectContaining({
        type: 'AGENT_SUBSCRIPTION_PUSH',
        subscriptionCount: 1,
      })
    );
    ```

  - [x] [Source: packages/connector/src/agent/agent-node.ts subscription matching, packages/connector/src/agent/subscription-manager.ts]

- [x] Task 13: Test TOON Encoding/Decoding Round-Trip (AC: 1)
  - [x] Create test: `it('should encode and decode events losslessly through ILP packet')`
  - [x] Test flow:

    ```typescript
    // Create complex event with tags
    const originalEvent = createTestEvent({
      kind: 1,
      content: 'Test message with Unicode: 你好',
      tags: [
        ['e', 'referenced-event-id'],
        ['p', 'referenced-pubkey'],
        ['custom', 'value1', 'value2'],
      ],
    });

    // Encode as TOON in ILP packet
    const packet = createTestPreparePacket(originalEvent, 100n, 'g.agent.b');

    // Process through agent (will decode internally)
    const response = await agentB.processIncomingPacket(packet, 'agent-a');

    // Verify event stored correctly
    expect(response.type).toBe(PacketType.FULFILL);
    const stored = await agentB.database.queryEvents({ ids: [originalEvent.id] });
    expect(stored).toHaveLength(1);
    expect(stored[0].content).toBe(originalEvent.content);
    expect(stored[0].tags).toEqual(originalEvent.tags);
    ```

  - [x] [Source: packages/connector/src/agent/toon-codec.ts, docs/prd/epic-13-agent-society-protocol.md line 236]

- [x] Task 14: Test Database Size Limit Enforcement (AC: 4)
  - [x] Create test: `it('should reject events when database size exceeded')`
  - [x] Test flow:

    ```typescript
    // Create agent with very small database limit (1KB)
    const smallAgent = new AgentNode({
      agentPubkey: getPublicKey(AGENT_A_PRIVKEY),
      databasePath: ':memory:',
      databaseMaxSize: 1024, // 1KB limit
      pricing: { noteStorage: 100n, followUpdate: 50n, deletion: 10n, queryBase: 200n },
    });
    await smallAgent.initialize();

    // Fill database with events until limit reached
    let rejected = false;
    for (let i = 0; i < 100 && !rejected; i++) {
      const event = createTestEvent({
        kind: 1,
        content: 'A'.repeat(100), // ~100 bytes per event
      });
      const packet = createTestPreparePacket(event, 100n, 'g.agent.test');
      const response = await smallAgent.processIncomingPacket(packet, 'external');
      if (response.type === PacketType.REJECT) {
        rejected = true;
        expect(response.code).toBe(ILPErrorCode.T00_INTERNAL_ERROR);
      }
    }

    expect(rejected).toBe(true);
    await smallAgent.shutdown();
    ```

  - [x] [Source: packages/connector/src/agent/event-database.ts DatabaseSizeExceededError]

- [x] Task 15: Document Test Coverage Matrix (AC: 1-5)
  - [x] Add test coverage documentation at end of test file:
    ```typescript
    /**
     * Test Coverage Matrix - Story 13.8 Acceptance Criteria
     *
     * AC1: Agent A queries Agent B's database
     *   - ✓ 'should query Agent B database and receive results'
     *   - ✓ 'should encode and decode events losslessly through ILP packet'
     *
     * AC2: Payment flows correctly between agents
     *   - ✓ 'should fulfill when payment is sufficient'
     *   - ✓ 'should reject when payment is insufficient'
     *   - ✓ 'should accept zero payment for free tier services'
     *
     * AC3: Events propagate through follow graph
     *   - ✓ 'should route events through follow graph'
     *   - ✓ 'should return F02 for unreachable destination'
     *   - ✓ 'should update routing table from Kind 3 event'
     *   - ✓ 'should match events to active subscriptions'
     *
     * AC4: Rejection codes returned for errors
     *   - ✓ 'should return F01 for malformed TOON data'
     *   - ✓ 'should return F03 for insufficient payment'
     *   - ✓ 'should return F99 for unsupported event kind'
     *   - ✓ 'should return T00 for internal errors'
     *   - ✓ 'should return T00 when agent not initialized'
     *   - ✓ 'should reject events when database size exceeded'
     *
     * AC5: Settlement triggers after threshold
     *   - ✓ 'should accumulate balance and detect settlement threshold'
     */
    ```

## Dev Notes

### Previous Story Insights

Story 13.7 (Agent Configuration Schema) completed the configuration system:

- **AgentConfigLoader** loads YAML config and converts to `AgentNodeConfig`
- **AgentYamlConfig** supports: agent identity, database, pricing, follows, handlers
- **Key file loading** supports raw hex, nsec bech32, and AES-256-GCM encrypted files
- **Environment variable fallback** via `AGENT_*` prefix
- **loadFollowsToRouter()** helper for static follow configuration

[Source: docs/stories/13.7.story.md Dev Agent Record section]

Story 13.6 (Agent Node Orchestrator) established the AgentNode patterns:

- **AgentNode** orchestrates all agent components (database, eventHandler, subscriptionManager, followGraphRouter)
- **processIncomingPacket()** is the main entry point for ILP packet processing
- **Telemetry emission** via `onTelemetry` callback
- **Graceful shutdown** via `shutdown()` method
- **AGENT_FULFILLMENT** and **AGENT_CONDITION** static values for deterministic fulfillment

[Source: docs/stories/13.6.story.md, packages/connector/src/agent/agent-node.ts]

Story 13.5 (Built-in Handlers) implemented the core handlers:

- **Kind 1 (Note)**: `createNoteHandler()` - stores events, returns success
- **Kind 3 (Follow)**: `createFollowHandler()` - updates routing table
- **Kind 5 (Delete)**: `createDeleteHandler()` - authorization check before deletion
- **Kind 10000 (Query)**: `createQueryHandler()` - parses filter from content
- **SubscriptionManager** provides filter matching via `getMatchingSubscriptions(event)`

[Source: docs/stories/13.5.story.md Dev Agent Record section]

### Technical Context

**Integration Test Architecture:**

The integration tests verify end-to-end flows across the Agent Society Protocol:

```
┌──────────────────────────────────────────────────────────────────────────┐
│                    Integration Test Scope                                 │
├──────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  Test Client ─────► AgentNode A ─────► AgentNode B ─────► AgentNode C   │
│       │                  │                  │                  │         │
│       │    ┌─────────────┼──────────────────┼──────────────────┼─────┐   │
│       │    │  Components │                  │                  │     │   │
│       │    │  Tested:    │                  │                  │     │   │
│       │    │             ▼                  ▼                  ▼     │   │
│       │    │  - ToonCodec (encode/decode)                            │   │
│       │    │  - AgentEventDatabase (store/query)                     │   │
│       │    │  - AgentEventHandler (dispatch/payment)                 │   │
│       │    │  - FollowGraphRouter (routing)                          │   │
│       │    │  - SubscriptionManager (matching)                       │   │
│       │    │  - Built-in Handlers (Kind 1, 3, 5, 10000)              │   │
│       │    └─────────────────────────────────────────────────────────┘   │
│       │                                                                   │
│       └──────► ILP Prepare ──► TOON Event ──► Handler ──► ILP Response  │
│                                                                          │
└──────────────────────────────────────────────────────────────────────────┘
```

[Source: docs/prd/epic-13-agent-society-protocol.md lines 155-166]

**Test Infrastructure Pattern:**

Following existing integration test patterns from the project:

```typescript
// Mock ESM-only @toon-format/toon package
jest.mock('@toon-format/toon', () => ({
  encode: (input: unknown) => JSON.stringify(input),
  decode: (input: string) => JSON.parse(input),
}));

// Test setup with proper cleanup
describe('Agent Integration', () => {
  let agentA: AgentNode;
  let agentB: AgentNode;

  beforeEach(async () => {
    agentA = new AgentNode(configA);
    agentB = new AgentNode(configB);
    await agentA.initialize();
    await agentB.initialize();
  });

  afterEach(async () => {
    await agentA.shutdown();
    await agentB.shutdown();
  });
});
```

[Source: packages/connector/test/integration/agent-config-integration.test.ts]

### Data Models

**ILPPreparePacket with TOON Data:**
[Source: docs/prd/epic-13-agent-society-protocol.md lines 51-59]

```typescript
interface ILPPreparePacket {
  type: PacketType.PREPARE;
  amount: bigint; // Payment for service
  destination: ILPAddress; // g.agent.* address
  executionCondition: Buffer;
  expiresAt: Date;
  data: Buffer; // TOON-serialized Nostr event
}
```

**AgentNodeConfig Interface:**
[Source: packages/connector/src/agent/agent-node.ts lines 30-56]

```typescript
interface AgentNodeConfig {
  agentPubkey: string;
  agentPrivkey?: string;
  databasePath: string;
  databaseMaxSize?: number;
  pricing: {
    noteStorage: bigint;
    followUpdate: bigint;
    deletion: bigint;
    queryBase: bigint;
    queryPerResult?: bigint;
  };
  enableBuiltInHandlers?: boolean;
  maxSubscriptionsPerPeer?: number;
}
```

**ILP Error Codes for Agent Errors:**
[Source: docs/prd/epic-13-agent-society-protocol.md lines 146-154]

| Scenario                 | ILP Error Code        |
| ------------------------ | --------------------- |
| Event kind not supported | F99_APPLICATION_ERROR |
| Insufficient payment     | F03_INVALID_AMOUNT    |
| Agent not found          | F02_UNREACHABLE       |
| Malformed event          | F01_INVALID_PACKET    |
| Temporary overload       | T03_CONNECTOR_BUSY    |
| Database error           | T00_INTERNAL_ERROR    |

### File Locations

**New Files (Story 13.8):**

```
packages/connector/test/integration/
├── agent-multi-agent.test.ts           # Main integration test file (NEW)
├── helpers/
│   └── agent-test-helpers.ts           # Test helper functions (NEW)
```

**Related Existing Files:**

```
packages/connector/
├── src/agent/
│   ├── agent-node.ts                   # AgentNode orchestrator
│   ├── event-database.ts               # Event storage
│   ├── event-handler.ts                # Event dispatch
│   ├── follow-graph-router.ts          # Follow graph routing
│   ├── subscription-manager.ts         # Subscription matching
│   ├── toon-codec.ts                   # TOON serialization
│   └── handlers/                       # Built-in handlers
├── test/integration/
│   ├── agent-config-integration.test.ts  # Config integration tests (reference)
│   ├── multi-node-forwarding.test.ts     # Multi-node test patterns (reference)
│   └── settlement-threshold-detection.test.ts  # Settlement patterns (reference)
```

[Source: docs/architecture/source-tree.md, docs/prd/epic-13-agent-society-protocol.md lines 209-224]

### Testing Requirements

**Test Framework:** Jest 29.7.x with TypeScript support
[Source: docs/architecture/tech-stack.md line 23]

**Integration Test Location:** `packages/connector/test/integration/`
[Source: docs/architecture/test-strategy-and-standards.md line 65]

**Required Test Coverage:**

- All 5 acceptance criteria must have at least one passing test
- Full event processing flow tested end-to-end
- All ILP error codes verified
- Payment validation tested (sufficient, insufficient, zero)
- Multi-agent routing verified

**Test Timeout Guidelines:**
[Source: docs/architecture/test-strategy-and-standards.md lines 297-300]

| Operation Type      | Timeout | Use Case                  |
| ------------------- | ------- | ------------------------- |
| Basic operations    | 50ms    | Single async handler      |
| Database operations | 100ms   | Store/query events        |
| Multi-agent flow    | 500ms   | Multiple async operations |

### Technical Constraints

**ESM Compatibility:**

The `@toon-format/toon` package is ESM-only. Tests must mock this package:

```typescript
jest.mock('@toon-format/toon', () => ({
  encode: (input: unknown) => JSON.stringify(input),
  decode: (input: string) => JSON.parse(input),
}));
```

[Source: packages/connector/test/integration/agent-config-integration.test.ts lines 8-12]

**TypeScript Configuration:**

- Strict mode enabled (`strict: true`)
- No `any` types except in test mocks
- Use async/await for all async operations
  [Source: docs/architecture/coding-standards.md lines 38-41]

**Test Isolation:**

- Create fresh AgentNode instances in `beforeEach()`
- Use `:memory:` database for isolation
- Always call `shutdown()` in `afterEach()`
- Use unique test keys to prevent cross-test interference
  [Source: docs/architecture/test-strategy-and-standards.md lines 860-867]

### Dependencies

**Existing Dependencies:**

- AgentNode, AgentNodeConfig (packages/connector/src/agent/agent-node.ts)
- ToonCodec, NostrEvent (packages/connector/src/agent/toon-codec.ts)
- AgentEventDatabase (packages/connector/src/agent/event-database.ts)
- FollowGraphRouter (packages/connector/src/agent/follow-graph-router.ts)
- SubscriptionManager (packages/connector/src/agent/subscription-manager.ts)
- ILPPreparePacket, ILPFulfillPacket, ILPRejectPacket, PacketType, ILPErrorCode (@m2m/shared)
- nostr-tools (2.10.0) for key generation and event signing

**Test Imports:**

```typescript
// Use explicit paths (matching existing integration test patterns)
import { AgentNode } from '../../src/agent/agent-node';
import type { AgentNodeConfig, AgentTelemetryEvent } from '../../src/agent/agent-node';
import { ToonCodec } from '../../src/agent/toon-codec';
import type { NostrEvent } from '../../src/agent/toon-codec';
import { ILPPreparePacket, PacketType, ILPErrorCode } from '@m2m/shared';
import { getPublicKey, finalizeEvent } from 'nostr-tools';
```

[Source: packages/connector/test/integration/agent-config-integration.test.ts lines 19-24]

### Edge Cases and Error Scenarios

**Query Processing:**

- Empty filter (query all) → Returns all events up to limit
- Invalid JSON in content → F01 error
- No matching events → Empty responseEvents array

**Payment Validation:**

- Zero payment with zero pricing → Success (free tier)
- Payment equal to required → Success
- Payment below required → F03 error with details

**Follow Graph Routing:**

- Destination not in follow graph → F02 error
- Multi-hop routing (A → B → C) → Verify routing table lookups

**Event Deletion:**

- Same author deletes own event → Success
- Different author attempts deletion → Event NOT deleted
- Delete non-existent event → Success (idempotent)

**Database Limits:**

- Storage exceeds limit → T00 error
- Query during shutdown → T00 error

## Testing

### Test File Locations

- `packages/connector/test/integration/agent-multi-agent.test.ts` - Main integration tests
- `packages/connector/test/integration/helpers/agent-test-helpers.ts` - Helper functions

[Source: docs/architecture/test-strategy-and-standards.md line 65]

### Test Framework

Jest 29.7.x with ts-jest for TypeScript support
[Source: docs/architecture/tech-stack.md line 23]

### Test Commands

```bash
# Run agent integration tests
npm test -- packages/connector/test/integration/agent-multi-agent.test.ts

# Run all agent-related tests
npm test -- packages/connector/test/integration/agent

# Run with coverage
npm test -- --coverage packages/connector/test/integration/agent

# Run with verbose output
npm test -- --verbose packages/connector/test/integration/agent-multi-agent.test.ts
```

### Test Coverage Requirements

- All 5 acceptance criteria must have passing tests
- Error path coverage for all ILP error codes
- Payment validation (F03) fully tested
- Routing scenarios (F02) verified
  [Source: docs/architecture/test-strategy-and-standards.md lines 7-12]

### Acceptance Criteria Verification

| AC# | Test Scenario                          | Verification Method                                            |
| --- | -------------------------------------- | -------------------------------------------------------------- |
| 1   | Agent A queries Agent B's database     | Test query Kind 10000 processing, verify results returned      |
| 2   | Payment flows correctly between agents | Test payment validation (sufficient, insufficient, zero)       |
| 3   | Events propagate through follow graph  | Test routing table lookups, follow event processing            |
| 4   | Rejection codes returned for errors    | Test F01, F03, F99, T00 error scenarios                        |
| 5   | Settlement triggers after threshold    | Test balance accumulation via multiple successful transactions |

---

## Change Log

| Date       | Version | Description                                                                                                                                                                                                                  | Author |
| ---------- | ------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------ |
| 2026-01-24 | 0.1     | Initial story draft creation                                                                                                                                                                                                 | SM     |
| 2026-01-24 | 0.2     | Validation fixes: (1) Moved Test Helpers Module to Task 2 for proper sequencing, (2) Updated imports to use explicit paths matching existing test patterns, (3) Added settlement integration verification guidance to Task 8 | SM     |
| 2026-01-24 | 1.0     | Implementation complete - All 19 tests passing                                                                                                                                                                               | Dev    |

---

## QA Results

### Review Date: 2026-01-24

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall: Excellent** - The implementation is well-structured, follows project patterns, and demonstrates comprehensive test coverage for the Agent Society Protocol integration tests. All 19 tests pass, covering all 5 acceptance criteria.

**Strengths:**

- Clean test organization with descriptive `describe` blocks mapping to Tasks
- Excellent use of helper functions extracted to reusable module (`agent-test-helpers.ts`)
- Proper ESM mock pattern for `@toon-format/toon` package
- Consistent AAA pattern (Arrange, Act, Assert) in test cases
- Comprehensive test coverage matrix documented at end of file
- Proper test isolation with `beforeEach`/`afterEach` setup and teardown
- Good use of `:memory:` SQLite databases for test isolation

**Minor Observations:**

- Tests correctly validate error scenarios (F01, F03, F99, T00 codes)
- Settlement threshold test appropriately verifies telemetry emission rather than actual settlement (matches boundary noted in story)

### Refactoring Performed

No refactoring performed. The implementation meets quality standards.

### Compliance Check

- Coding Standards: ✓ Follows naming conventions, TypeScript strict mode, no `any` types
- Project Structure: ✓ Files in correct locations (`test/integration/`, `test/integration/helpers/`)
- Testing Strategy: ✓ Integration tests follow project patterns, proper cleanup, isolation
- All ACs Met: ✓ All 5 acceptance criteria have test coverage

### Improvements Checklist

All items were implemented correctly by the developer:

- [x] Test infrastructure and fixtures created
- [x] Test helpers module extracted for reuse
- [x] Two-agent communication tests implemented
- [x] Database query tests (AC1) passing
- [x] Payment validation tests (AC2) passing - sufficient, insufficient, free tier
- [x] Follow graph routing tests (AC3) passing
- [x] Rejection code tests (AC4) passing - F01, F03, F99, T00
- [x] Settlement threshold detection tests (AC5) passing via telemetry
- [x] Kind 3 follow event processing tests passing
- [x] Kind 5 delete event processing tests passing
- [x] Telemetry emission tests passing
- [x] Subscription matching tests passing
- [x] TOON encoding round-trip tests passing
- [x] Database size limit enforcement tests passing
- [x] Test coverage matrix documented

### Security Review

- ✓ No hardcoded credentials (test keys are intentional test constants)
- ✓ Authorization check verified in Kind 5 delete tests (unauthorized deletion prevented)
- ✓ Payment validation enforces minimum amounts before processing
- ✓ No security vulnerabilities identified in test code

### Performance Considerations

- ✓ Tests use in-memory databases for fast execution
- ✓ Test suite completes in ~2.6 seconds (well within acceptable limits)
- ✓ No unnecessary delays or sleeps in tests
- ✓ Proper async/await patterns used throughout

### Files Modified During Review

None - no modifications required.

### Gate Status

Gate: **PASS** → docs/qa/gates/13.8-integration-tests.yml

### Recommended Status

✓ **Ready for Done**

All acceptance criteria are fully met with passing tests. The implementation follows project coding standards and test strategy guidelines. No blocking issues identified.

---

## Dev Agent Record

### Agent Model Used

Claude Opus 4.5 (claude-opus-4-5-20251101)

### File List

| File                                                                | Status  | Description                                                                             |
| ------------------------------------------------------------------- | ------- | --------------------------------------------------------------------------------------- |
| `packages/connector/test/integration/agent-multi-agent.test.ts`     | Created | Main multi-agent integration test file with 19 tests covering all 5 acceptance criteria |
| `packages/connector/test/integration/helpers/agent-test-helpers.ts` | Created | Test helper functions for creating events, packets, configs, and agents                 |

### Completion Notes

- All 15 tasks completed successfully
- 19 integration tests implemented and passing
- Tests cover all 5 acceptance criteria:
  - AC1: Database query between agents (Kind 10000 processing)
  - AC2: Payment validation (sufficient, insufficient, free tier)
  - AC3: Follow graph routing and subscription matching
  - AC4: ILP error codes (F01, F03, F99, T00)
  - AC5: Settlement threshold detection via telemetry
- Test helpers extracted to reusable module for future tests
- ESM mock for @toon-format/toon package implemented (JSON serialization fallback)
- Test coverage matrix documented at end of test file

### Debug Log References

None - all tests passed on first successful run after TypeScript fixes.
