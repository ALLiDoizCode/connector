# Story 13.3: Off-Chain Claim Signing and Verification

## Status

Done

## Story

**As a** connector,
**I want** to sign and verify Aptos payment channel claims off-chain,
**so that** I can authorize APT transfers to peers without on-chain transactions.

## Acceptance Criteria

1. `AptosClaimSigner` class implemented in `packages/connector/src/settlement/aptos-claim-signer.ts`
2. Claim signer uses ed25519 keypair for signing (compatible with Aptos on-chain verification)
3. Claim signer implements `signClaim(channelOwner, amount, nonce)` method producing signature
4. Claim message format: `CLAIM_APTOS | channelOwner | amount | nonce` (canonical BCS encoding)
5. Claim signer implements `verifyClaim(channelOwner, amount, nonce, signature, publicKey)` method
6. Claim verification checks signature validity and nonce is greater than previous
7. Claim signer maintains highest nonce per channel to prevent double-spending
8. Claim signer stores latest signed claim for dispute resolution
9. Unit tests verify claim signing and verification with various amounts and nonces
10. Integration test validates claim signing and local verification; full on-chain submission test deferred to Story 13.4 (requires AptosChannelSDK)

## Dev Notes

### Previous Story Insights

**From Story 13.1 (Aptos SDK Integration):**
[Source: docs/stories/13.1.story.md]

- AptosClient wrapper implemented with @aptos-labs/ts-sdk@^1.39.0
- Error handling uses AptosErrorCode enum with 14 error types mapped from Aptos API errors
- Connection retry logic: exponential backoff with 1s/2s/4s delays, max 3 attempts
- Unit test coverage achieved: 89.75% (exceeds 80% requirement)
- All amounts in octas (1 APT = 100,000,000 octas), stored as bigint
- ed25519 keys used for Aptos account signatures (same scheme for claim verification)
- AptosClient.view() method available for calling view functions on deployed modules
- AptosClient.submitTransaction() method handles transaction signing and confirmation
- Factory function `createAptosClientFromEnv()` available for environment-based configuration

**From Story 13.2 (Move Payment Channel Module):**
[Source: docs/stories/13.2.story.md]

- Move module at `packages/contracts-aptos/sources/payment_channel.move` implements:
  - `open_channel(destination, destination_pubkey, amount, settle_delay)` - creates channel
  - `deposit(amount)` - adds funds to existing channel
  - `claim(owner, amount, nonce, signature)` - destination submits signed balance proof
  - `request_close(channel_owner)` and `finalize_close(channel_owner)` - two-phase closure
- Claim signature verification in Move uses ed25519::signature_verify_strict()
- **Critical: Claim message format is `"CLAIM_APTOS" || owner (BCS) || amount (BCS) || nonce (BCS)`**
- BCS (Binary Canonical Serialization) is used for deterministic message encoding
- Signature must be exactly 64 bytes (ed25519 signature)
- Public key must be exactly 32 bytes (ed25519 public key)
- Nonce is monotonically increasing - each claim must have nonce > previous
- Amount in claims is cumulative (not incremental) - represents total claimed so far

**Key Learnings from Previous Stories:**

- TypeScript SDK uses TypeScript types extensively; need proper type imports
- Error mapping should preserve original error for debugging
- Pattern: store bound handlers in constructor for proper event listener cleanup
- Test timeout of 50-100ms needed for async event handler processing

### Data Models

**AptosClaim Interface:**
[Source: docs/prd/epic-13-aptos-payment-channels.md#story-273]

```typescript
/**
 * Aptos Payment Channel Claim Structure
 *
 * Represents a signed balance proof that can be submitted on-chain
 * to claim APT from a payment channel.
 */
export interface AptosClaim {
  /**
   * Aptos address of the channel owner (payer)
   * Format: 0x-prefixed 64-character hex
   */
  channelOwner: string;

  /**
   * Cumulative amount in octas (1 APT = 100,000,000 octas)
   * This is the TOTAL amount claimed so far, not incremental
   */
  amount: bigint;

  /**
   * Monotonically increasing counter for replay protection
   * Each claim must have nonce > previous claim's nonce
   */
  nonce: number;

  /**
   * ed25519 signature over the claim message
   * Format: hex string (64 bytes = 128 hex characters)
   */
  signature: string;

  /**
   * ed25519 public key of the signer (claim creator)
   * Format: hex string (32 bytes = 64 hex characters)
   * Used for on-chain verification
   */
  publicKey: string;

  /**
   * Timestamp when this claim was created
   * Used for dispute resolution and claim ordering
   */
  createdAt: number;
}
```

**AptosClaimSignerConfig Interface:**
[Source: Story 13.3 requirements + coding standards]

```typescript
/**
 * Configuration for AptosClaimSigner
 */
export interface AptosClaimSignerConfig {
  /**
   * ed25519 private key for claim signing
   * Format: 64-character hex string (32 bytes)
   * MUST be stored in environment variable (APTOS_CLAIM_PRIVATE_KEY)
   */
  privateKey: string;

  /**
   * Optional: Initial nonce state per channel (for recovery)
   * Map from channelOwner address to highest known nonce
   */
  initialNonceState?: Map<string, number>;
}
```

**ChannelClaimState Interface:**
[Source: Story 13.3 requirements for AC #7, #8]

```typescript
/**
 * Tracks claim state per payment channel for dispute resolution
 * Used for claims WE SIGN (outgoing claims to peers)
 */
interface ChannelClaimState {
  /**
   * Highest nonce signed for this channel
   */
  highestNonce: number;

  /**
   * Highest cumulative amount claimed
   */
  highestAmount: bigint;

  /**
   * Latest claim signed (for dispute resolution)
   */
  latestClaim: AptosClaim;
}

/**
 * Tracks received claim state from peers
 * Used for claims WE RECEIVE AND VERIFY (incoming claims from peers)
 * Keyed by composite key: `${channelOwner}:${peerPublicKey}`
 */
interface ReceivedClaimState {
  /**
   * Highest nonce received and verified from this peer
   */
  highestNonce: number;

  /**
   * Latest verified claim from this peer
   */
  latestClaim: AptosClaim;
}
```

**AptosClaimError Class:**
[Source: Story 13.1 AptosError pattern + Story 13.3 requirements]

```typescript
/**
 * Aptos Claim Error Codes
 *
 * Error codes for claim signing and verification operations.
 * Follows AptosErrorCode pattern from Story 13.1.
 */
export enum AptosClaimErrorCode {
  // Nonce errors
  INVALID_NONCE = 'APTOS_CLAIM_INVALID_NONCE', // Nonce <= previous nonce
  STALE_NONCE = 'APTOS_CLAIM_STALE_NONCE', // Received claim has stale nonce

  // Signature errors
  INVALID_SIGNATURE = 'APTOS_CLAIM_INVALID_SIGNATURE', // Signature verification failed
  MALFORMED_SIGNATURE = 'APTOS_CLAIM_MALFORMED_SIGNATURE', // Signature format invalid

  // Key errors
  MALFORMED_PUBLIC_KEY = 'APTOS_CLAIM_MALFORMED_PUBLIC_KEY', // Public key format invalid

  // General errors
  ENCODING_ERROR = 'APTOS_CLAIM_ENCODING_ERROR', // BCS encoding failed
}

/**
 * Aptos Claim Error Class
 *
 * Thrown for claim signing/verification errors.
 */
export class AptosClaimError extends Error {
  constructor(
    public readonly code: AptosClaimErrorCode,
    message: string,
    public readonly originalError?: Error | unknown
  ) {
    super(message);
    this.name = 'AptosClaimError';
  }
}
```

### API Specifications

**IAptosClaimSigner Interface:**
[Source: docs/prd/epic-13-aptos-payment-channels.md#story-273]

```typescript
/**
 * Aptos Claim Signer Interface
 *
 * Signs and verifies off-chain balance proofs for Aptos payment channels.
 * Compatible with Move module ed25519 signature verification.
 *
 * Implementation: packages/connector/src/settlement/aptos-claim-signer.ts
 */
export interface IAptosClaimSigner {
  /**
   * Sign a claim for a payment channel
   *
   * Creates an ed25519 signature over the canonical claim message.
   * Message format: "CLAIM_APTOS" || channelOwner (BCS) || amount (BCS) || nonce (BCS)
   *
   * @param channelOwner - Aptos address of the channel owner (0x-prefixed hex)
   * @param amount - Cumulative amount in octas (TOTAL claimed, not incremental)
   * @param nonce - Must be greater than any previously signed nonce for this channel
   * @returns AptosClaim with signature
   * @throws Error if nonce <= previously signed nonce for this channel
   */
  signClaim(channelOwner: string, amount: bigint, nonce: number): AptosClaim;

  /**
   * Verify a claim signature from a peer
   *
   * Validates that the signature matches the claim data using the provided public key.
   *
   * **Nonce Tracking Behavior:**
   * - Tracks received claims SEPARATELY from signed claims (different state)
   * - Uses (channelOwner, publicKey) as composite key for tracking peer claims
   * - Rejects claims with nonce <= highest previously verified nonce from same peer
   * - This prevents replay attacks from peers resending old claims
   *
   * @param channelOwner - Aptos address of the channel owner
   * @param amount - Cumulative amount in octas
   * @param nonce - Claim nonce
   * @param signature - ed25519 signature (hex string)
   * @param publicKey - ed25519 public key of signer (hex string)
   * @returns true if signature is valid and nonce is fresh, false otherwise
   */
  verifyClaim(
    channelOwner: string,
    amount: bigint,
    nonce: number,
    signature: string,
    publicKey: string
  ): boolean;

  /**
   * Get the highest nonce received from a peer for a channel
   *
   * Used to track replay protection for received claims.
   * Tracked separately from signed claims.
   *
   * @param channelOwner - Aptos address of the channel owner
   * @param publicKey - Public key of the peer who signed claims
   * @returns Highest verified nonce from this peer, or 0 if none
   */
  getHighestReceivedNonce(channelOwner: string, publicKey: string): number;

  /**
   * Get the public key for this signer
   *
   * Returns the ed25519 public key that corresponds to this signer's private key.
   * Used to share with channel owners for on-chain claim verification.
   *
   * @returns Public key as hex string (32 bytes = 64 hex characters)
   */
  getPublicKey(): string;

  /**
   * Get the highest nonce signed for a channel
   *
   * Used to determine next valid nonce when creating claims.
   *
   * @param channelOwner - Aptos address of the channel owner
   * @returns Highest signed nonce, or 0 if no claims signed for this channel
   */
  getHighestNonce(channelOwner: string): number;

  /**
   * Get the latest claim for a channel
   *
   * Returns the most recent claim signed for dispute resolution.
   *
   * @param channelOwner - Aptos address of the channel owner
   * @returns Latest AptosClaim or null if no claims signed
   */
  getLatestClaim(channelOwner: string): AptosClaim | null;

  /**
   * Get all channels with signed claims
   *
   * Returns list of channel owner addresses that have signed claims.
   * Used for claim state recovery and monitoring.
   *
   * @returns Array of channel owner addresses
   */
  getChannelOwners(): string[];
}
```

### BCS Encoding Implementation

**Critical: Matching Move BCS Encoding:**
[Source: packages/contracts-aptos/sources/payment_channel.move#verify_claim_signature]

The TypeScript implementation MUST produce identical bytes to Move's BCS encoding:

```typescript
import { bcs } from '@aptos-labs/ts-sdk';

/**
 * Construct canonical claim message matching Move BCS encoding
 *
 * MUST match Move module's verify_claim_signature():
 *   let message = b"CLAIM_APTOS";
 *   vector::append(&mut message, bcs::to_bytes(&channel_owner));
 *   vector::append(&mut message, bcs::to_bytes(&amount));
 *   vector::append(&mut message, bcs::to_bytes(&nonce));
 */
function constructClaimMessage(channelOwner: string, amount: bigint, nonce: number): Uint8Array {
  // "CLAIM_APTOS" as bytes
  const prefix = new TextEncoder().encode('CLAIM_APTOS');

  // BCS encode address (32 bytes)
  const addressBytes = bcs
    .bytes(32)
    .serialize(Buffer.from(channelOwner.replace('0x', ''), 'hex'))
    .toUint8Array();

  // BCS encode amount (u64)
  const amountBytes = bcs.u64().serialize(amount).toUint8Array();

  // BCS encode nonce (u64)
  const nonceBytes = bcs.u64().serialize(BigInt(nonce)).toUint8Array();

  // Concatenate all parts
  const message = new Uint8Array(
    prefix.length + addressBytes.length + amountBytes.length + nonceBytes.length
  );
  let offset = 0;
  message.set(prefix, offset);
  offset += prefix.length;
  message.set(addressBytes, offset);
  offset += addressBytes.length;
  message.set(amountBytes, offset);
  offset += amountBytes.length;
  message.set(nonceBytes, offset);

  return message;
}
```

### ed25519 Signature Implementation

**Using @aptos-labs/ts-sdk for ed25519:**
[Source: @aptos-labs/ts-sdk + Story 13.1 patterns]

```typescript
import { Ed25519PrivateKey, Ed25519PublicKey, Ed25519Signature } from '@aptos-labs/ts-sdk';

class AptosClaimSigner implements IAptosClaimSigner {
  private readonly privateKey: Ed25519PrivateKey;
  private readonly publicKey: Ed25519PublicKey;
  private readonly channelStates: Map<string, ChannelClaimState>; // Our signed claims
  private readonly receivedClaimStates: Map<string, ReceivedClaimState>; // Peer claims
  private readonly logger: Logger;

  constructor(config: AptosClaimSignerConfig, logger: Logger) {
    this.privateKey = new Ed25519PrivateKey(config.privateKey);
    this.publicKey = this.privateKey.publicKey();
    this.channelStates = new Map();
    this.receivedClaimStates = new Map(); // Separate tracking for peer claims
    this.logger = logger;

    // Initialize nonce state if provided (for recovery)
    if (config.initialNonceState) {
      for (const [channelOwner, nonce] of config.initialNonceState) {
        this.channelStates.set(channelOwner, {
          highestNonce: nonce,
          highestAmount: BigInt(0),
          latestClaim: null as unknown as AptosClaim, // Will be set on first claim
        });
      }
    }
  }

  /**
   * Get composite key for received claim tracking
   * Format: channelOwner:peerPublicKey
   */
  private getReceivedClaimKey(channelOwner: string, peerPublicKey: string): string {
    return `${channelOwner.toLowerCase()}:${peerPublicKey.toLowerCase()}`;
  }

  getHighestReceivedNonce(channelOwner: string, publicKey: string): number {
    const key = this.getReceivedClaimKey(channelOwner, publicKey);
    return this.receivedClaimStates.get(key)?.highestNonce ?? 0;
  }

  signClaim(channelOwner: string, amount: bigint, nonce: number): AptosClaim {
    // Get or create channel state
    const state = this.channelStates.get(channelOwner);
    const currentHighestNonce = state?.highestNonce ?? 0;

    // Validate nonce is strictly greater
    if (nonce <= currentHighestNonce) {
      throw new AptosClaimError(
        AptosClaimErrorCode.INVALID_NONCE,
        `Invalid nonce: ${nonce} must be greater than ${currentHighestNonce}`
      );
    }

    // Construct message
    const message = constructClaimMessage(channelOwner, amount, nonce);

    // Sign with ed25519
    const signature = this.privateKey.sign(message);

    // Create claim object
    const claim: AptosClaim = {
      channelOwner,
      amount,
      nonce,
      signature: signature.toString(), // Hex string
      publicKey: this.publicKey.toString(), // Hex string
      createdAt: Date.now(),
    };

    // Update channel state
    this.channelStates.set(channelOwner, {
      highestNonce: nonce,
      highestAmount: amount,
      latestClaim: claim,
    });

    this.logger.info({ channelOwner, amount: amount.toString(), nonce }, 'Claim signed');

    return claim;
  }

  verifyClaim(
    channelOwner: string,
    amount: bigint,
    nonce: number,
    signature: string,
    publicKey: string
  ): boolean {
    try {
      // Validate nonce freshness against RECEIVED claims from this peer
      // Uses composite key: channelOwner + peerPublicKey
      const key = this.getReceivedClaimKey(channelOwner, publicKey);
      const receivedState = this.receivedClaimStates.get(key);
      if (receivedState && nonce <= receivedState.highestNonce) {
        this.logger.warn(
          {
            channelOwner,
            nonce,
            highestNonce: receivedState.highestNonce,
            peerPublicKey: publicKey,
          },
          'Claim verification failed: stale nonce from peer'
        );
        return false;
      }

      // Construct message
      const message = constructClaimMessage(channelOwner, amount, nonce);

      // Parse signature and public key
      const sig = new Ed25519Signature(signature);
      const pk = new Ed25519PublicKey(publicKey);

      // Verify signature
      const isValid = pk.verifySignature({ message, signature: sig });

      if (isValid) {
        // Update received claim state for this peer
        this.receivedClaimStates.set(key, {
          highestNonce: nonce,
          latestClaim: {
            channelOwner,
            amount,
            nonce,
            signature,
            publicKey,
            createdAt: Date.now(),
          },
        });

        this.logger.info(
          { channelOwner, amount: amount.toString(), nonce, peerPublicKey: publicKey },
          'Claim verification succeeded'
        );
      } else {
        this.logger.warn(
          { channelOwner, amount: amount.toString(), nonce },
          'Claim verification failed: invalid signature'
        );
      }

      return isValid;
    } catch (error) {
      this.logger.error({ error, channelOwner, nonce }, 'Claim verification error');
      return false;
    }
  }
}
```

### Component Specifications

**File Locations:**
[Source: docs/architecture/source-tree.md + existing settlement files pattern]

- **AptosClaimSigner implementation:** `packages/connector/src/settlement/aptos-claim-signer.ts`
- **AptosClaimSigner unit tests:** `packages/connector/src/settlement/aptos-claim-signer.test.ts`
- **Integration tests:** `packages/connector/test/integration/aptos-claim-signer.test.ts`

**Environment Variable Configuration:**
[Source: Story 13.1 patterns + Epic 13.3 requirements]

Add to `packages/connector/.env.example`:

```bash
# Aptos Claim Signing (Epic 13.3)
# Separate key from account key for security (claim signing vs account operations)
APTOS_CLAIM_PRIVATE_KEY=0x0000000000000000000000000000000000000000000000000000000000000001  # MUST replace
```

**Dependencies:**
[Source: Story 13.1 - @aptos-labs/ts-sdk already installed]

No new dependencies required. Uses:

- `@aptos-labs/ts-sdk` (already installed in Story 13.1) for:
  - `Ed25519PrivateKey`, `Ed25519PublicKey`, `Ed25519Signature` for signing
  - `bcs` for canonical serialization matching Move BCS encoding

### Testing Requirements

**Unit Tests (packages/connector/src/settlement/aptos-claim-signer.test.ts):**
[Source: docs/architecture/test-strategy-and-standards.md]

```typescript
describe('AptosClaimSigner', () => {
  let signer: AptosClaimSigner;
  let mockLogger: jest.Mocked<Logger>;

  // Test keypair (for deterministic testing)
  const TEST_PRIVATE_KEY = '0x0000000000000000000000000000000000000000000000000000000000000001';

  beforeEach(() => {
    mockLogger = { info: jest.fn(), warn: jest.fn(), error: jest.fn() } as any;
    signer = new AptosClaimSigner({ privateKey: TEST_PRIVATE_KEY }, mockLogger);
  });

  describe('signClaim()', () => {
    it('should produce valid ed25519 signature', () => {
      const claim = signer.signClaim('0x1', BigInt(100), 1);
      expect(claim.signature).toHaveLength(128); // 64 bytes = 128 hex chars
      expect(claim.publicKey).toHaveLength(64); // 32 bytes = 64 hex chars
    });

    it('should reject nonce <= previous nonce', () => {
      signer.signClaim('0x1', BigInt(100), 5);
      expect(() => signer.signClaim('0x1', BigInt(200), 5)).toThrow(AptosClaimError);
      expect(() => signer.signClaim('0x1', BigInt(200), 3)).toThrow(AptosClaimError);
    });

    it('should throw AptosClaimError with INVALID_NONCE code', () => {
      signer.signClaim('0x1', BigInt(100), 5);
      try {
        signer.signClaim('0x1', BigInt(200), 3);
        fail('Expected AptosClaimError');
      } catch (error) {
        expect(error).toBeInstanceOf(AptosClaimError);
        expect((error as AptosClaimError).code).toBe(AptosClaimErrorCode.INVALID_NONCE);
      }
    });

    it('should allow first claim with nonce 1', () => {
      const claim = signer.signClaim('0x1', BigInt(100), 1);
      expect(claim.nonce).toBe(1);
    });

    it('should track highest nonce per channel independently', () => {
      signer.signClaim('0x1', BigInt(100), 5);
      signer.signClaim('0x2', BigInt(200), 3);

      expect(signer.getHighestNonce('0x1')).toBe(5);
      expect(signer.getHighestNonce('0x2')).toBe(3);
    });

    it('should store latest claim for dispute resolution', () => {
      const claim1 = signer.signClaim('0x1', BigInt(100), 1);
      const claim2 = signer.signClaim('0x1', BigInt(200), 2);

      expect(signer.getLatestClaim('0x1')).toEqual(claim2);
    });
  });

  describe('verifyClaim()', () => {
    it('should verify valid signature', () => {
      const claim = signer.signClaim('0x1', BigInt(100), 1);
      const isValid = signer.verifyClaim(
        claim.channelOwner,
        claim.amount,
        claim.nonce,
        claim.signature,
        claim.publicKey
      );
      expect(isValid).toBe(true);
    });

    it('should reject invalid signature', () => {
      const claim = signer.signClaim('0x1', BigInt(100), 1);
      const isValid = signer.verifyClaim(
        claim.channelOwner,
        BigInt(999), // Wrong amount
        claim.nonce,
        claim.signature,
        claim.publicKey
      );
      expect(isValid).toBe(false);
    });

    it('should reject stale nonce', () => {
      signer.signClaim('0x1', BigInt(100), 5);
      const oldClaim = { ...signer.signClaim('0x1', BigInt(200), 10) };

      // Try to verify with nonce <= 10
      const isValid = signer.verifyClaim(
        '0x1',
        BigInt(150),
        8,
        oldClaim.signature,
        oldClaim.publicKey
      );
      expect(isValid).toBe(false);
    });
  });

  describe('getPublicKey()', () => {
    it('should return consistent public key', () => {
      const pk1 = signer.getPublicKey();
      const pk2 = signer.getPublicKey();
      expect(pk1).toBe(pk2);
      expect(pk1).toHaveLength(64); // 32 bytes hex
    });
  });

  describe('BCS encoding compatibility', () => {
    it('should produce deterministic message bytes', () => {
      // Sign same data twice - signatures should be identical
      const signer1 = new AptosClaimSigner({ privateKey: TEST_PRIVATE_KEY }, mockLogger);
      const signer2 = new AptosClaimSigner({ privateKey: TEST_PRIVATE_KEY }, mockLogger);

      const claim1 = signer1.signClaim('0x1', BigInt(100), 1);
      const claim2 = signer2.signClaim('0x1', BigInt(100), 1);

      expect(claim1.signature).toBe(claim2.signature);
    });
  });

  describe('Received claim tracking (separate from signed claims)', () => {
    it('should track received claims separately from signed claims', () => {
      // Sign a claim (our outgoing claim)
      const signedClaim = signer.signClaim('0x1', BigInt(100), 5);

      // Verify a claim from a peer (incoming claim)
      const peerPublicKey = '0x' + 'ab'.repeat(32); // Different peer
      const isValid = signer.verifyClaim(
        '0x1',
        signedClaim.amount,
        signedClaim.nonce,
        signedClaim.signature,
        signedClaim.publicKey // Our own public key for this test
      );

      // Our signed nonce should still be 5
      expect(signer.getHighestNonce('0x1')).toBe(5);

      // Received nonce tracking is independent
      expect(signer.getHighestReceivedNonce('0x1', signedClaim.publicKey)).toBe(5);
    });

    it('should reject stale nonce from same peer', () => {
      const claim1 = signer.signClaim('0x1', BigInt(100), 5);

      // Verify first claim from peer
      signer.verifyClaim('0x1', claim1.amount, claim1.nonce, claim1.signature, claim1.publicKey);

      // Try to verify older nonce from same peer - should fail
      const claim2 = signer.signClaim('0x1', BigInt(50), 6); // We sign with nonce 6
      // But if peer sends nonce 3, it should be rejected
      const isValid = signer.verifyClaim('0x1', BigInt(50), 3, claim2.signature, claim1.publicKey);
      expect(isValid).toBe(false);
    });

    it('should allow same nonce from different peers', () => {
      const claim = signer.signClaim('0x1', BigInt(100), 5);

      // Verify from peer A
      signer.verifyClaim('0x1', claim.amount, claim.nonce, claim.signature, claim.publicKey);

      // Different peer can send same nonce (they have independent tracking)
      const differentPeerKey = '0x' + 'cd'.repeat(32);
      // Note: signature won't be valid for different key, but nonce check should pass
      // The test verifies nonce tracking is per-peer
      expect(signer.getHighestReceivedNonce('0x1', differentPeerKey)).toBe(0);
    });

    it('should track getHighestReceivedNonce correctly', () => {
      expect(signer.getHighestReceivedNonce('0x1', 'peer1')).toBe(0);

      const claim = signer.signClaim('0x1', BigInt(100), 10);
      signer.verifyClaim('0x1', claim.amount, claim.nonce, claim.signature, claim.publicKey);

      expect(signer.getHighestReceivedNonce('0x1', claim.publicKey)).toBe(10);
    });
  });
});
```

**Integration Tests (packages/connector/test/integration/aptos-claim-signer.test.ts):**
[Source: Epic 13 Story 13.3 AC #10]

```typescript
/**
 * Integration tests for AptosClaimSigner with Aptos testnet
 *
 * Prerequisites:
 * - Internet connectivity to Aptos testnet
 * - APTOS_PRIVATE_KEY, APTOS_ACCOUNT_ADDRESS configured
 * - APTOS_CLAIM_PRIVATE_KEY configured (can be same as account key for testing)
 * - Move payment channel module deployed to testnet
 *
 * These tests verify end-to-end claim signing → on-chain submission → APT transfer
 */
describe('AptosClaimSigner Integration (Testnet)', () => {
  let client: AptosClient;
  let claimSigner: AptosClaimSigner;
  let logger: Logger;

  beforeAll(async () => {
    // Skip if environment not configured
    if (!process.env.APTOS_PRIVATE_KEY || !process.env.APTOS_CLAIM_PRIVATE_KEY) {
      console.log('Skipping Aptos claim integration tests: environment not configured');
      return;
    }

    logger = createLogger({ level: 'info' });
    client = createAptosClientFromEnv(logger);
    await client.connect();

    claimSigner = new AptosClaimSigner(
      { privateKey: process.env.APTOS_CLAIM_PRIVATE_KEY! },
      logger
    );
  });

  afterAll(() => {
    client?.disconnect();
  });

  it('should sign claim that can be verified on-chain', async () => {
    if (!client) return;

    // This test requires a deployed Move module and open channel
    // Skip if module not deployed
    const moduleAddress = process.env.APTOS_MODULE_ADDRESS;
    if (!moduleAddress) {
      console.log('Skipping: APTOS_MODULE_ADDRESS not set');
      return;
    }

    const channelOwner = client.getAddress();
    const claim = claimSigner.signClaim(channelOwner, BigInt(100), 1);

    // Verify claim can be verified locally
    const isValid = claimSigner.verifyClaim(
      claim.channelOwner,
      claim.amount,
      claim.nonce,
      claim.signature,
      claim.publicKey
    );
    expect(isValid).toBe(true);
  });

  /**
   * BCS Encoding Cross-Validation Test
   *
   * CRITICAL: This test validates that TypeScript BCS encoding matches Move BCS encoding.
   * If this test fails, ALL on-chain signature verifications will fail.
   *
   * Requires: Move module deployed with a view function to verify signatures
   */
  it('should produce BCS encoding compatible with Move module', async () => {
    if (!client) return;

    const moduleAddress = process.env.APTOS_MODULE_ADDRESS;
    if (!moduleAddress) {
      console.log('Skipping BCS validation: APTOS_MODULE_ADDRESS not set');
      return;
    }

    const channelOwner = client.getAddress();
    const amount = BigInt(1000000); // 0.01 APT
    const nonce = 1;

    const claim = claimSigner.signClaim(channelOwner, amount, nonce);

    // Call Move module view function to verify signature on-chain
    // This validates that our BCS encoding matches Move's encoding
    try {
      const result = await client.view(
        moduleAddress,
        'payment_channel',
        'verify_signature_view', // View function that verifies without state changes
        [],
        [channelOwner, amount.toString(), nonce.toString(), claim.signature, claim.publicKey]
      );

      expect(result[0]).toBe(true);
      console.log('BCS encoding cross-validation: PASS');
    } catch (error) {
      // If view function doesn't exist, skip test
      console.log('Skipping BCS validation: verify_signature_view not available');
    }
  });
});
```

**Coverage Requirements:**
[Source: docs/architecture/test-strategy-and-standards.md]

- Unit tests: >80% coverage for AptosClaimSigner
- Test all public methods: signClaim, verifyClaim, getPublicKey, getHighestNonce, getLatestClaim, getChannelOwners
- Test error conditions: invalid nonce, invalid signature, malformed input
- Test BCS encoding produces deterministic bytes

### Technical Constraints

**ed25519 Signature Constraints:**
[Source: Move module + Aptos SDK]

1. **Signature Format:** Must be exactly 64 bytes (128 hex characters)
2. **Public Key Format:** Must be exactly 32 bytes (64 hex characters)
3. **Message Format:** Must exactly match Move BCS encoding - any byte difference causes verification failure
4. **Deterministic Signing:** ed25519 signatures are deterministic - same message + key = same signature

**BCS Encoding Constraints:**
[Source: packages/contracts-aptos/sources/payment_channel.move]

1. **Address Encoding:** 32 bytes, NOT variable length (no length prefix)
2. **u64 Encoding:** 8 bytes little-endian
3. **String Prefix:** "CLAIM_APTOS" as raw UTF-8 bytes (no length prefix)
4. **Concatenation Order:** prefix || address || amount || nonce

**Nonce Management Constraints:**
[Source: Epic 13 Story 13.3 AC #6, #7]

1. **Strictly Increasing:** Each claim nonce must be > previous nonce for that channel
2. **Per-Channel Tracking:** Nonces are tracked independently per channel owner
3. **No Gaps Required:** Nonces don't need to be sequential (1, 5, 100 is valid)
4. **Amount Cumulative:** Amount represents total claimed, not delta since last claim

### Security Considerations

**Key Management:**
[Source: Epic 13 Security Considerations]

1. **Separate Claim Key:** APTOS_CLAIM_PRIVATE_KEY should be different from APTOS_PRIVATE_KEY (key isolation)
2. **Never Log Keys:** Private key must never appear in logs
3. **Secure Storage:** Keys must be environment variables, never in code

**Replay Protection:**
[Source: Epic 13.3 requirements]

1. **Nonce Tracking:** Signer tracks highest nonce to prevent signing lower nonces
2. **Verification Nonce Check:** verifyClaim() rejects nonces <= previously verified
3. **State Persistence:** Consider persisting nonce state to disk for recovery (future enhancement)

### Project Structure Notes

**File Organization:**
[Source: docs/architecture/source-tree.md + existing settlement files]

The claim signer follows existing settlement module patterns:

- Co-located with other settlement files in `packages/connector/src/settlement/`
- Uses same logger pattern as AptosClient (Pino)
- Follows IAptosClaimSigner interface pattern like IAptosClient

**Integration with Story 13.4:**
Story 13.4 (AptosChannelSDK) will consume AptosClaimSigner for:

- `signClaim()` when creating off-chain balance proofs
- `verifyClaim()` when receiving claims from peers
- `getPublicKey()` to share with channel owners during `open_channel()`

## Tasks / Subtasks

**Task Execution Strategy:** This story implements off-chain claim signing/verification. Task 1 defines interfaces and data models. Task 2 implements BCS encoding matching Move. Task 3 implements ed25519 signing. Task 4 implements signature verification. Task 5 implements nonce tracking and claim storage. Task 6 implements unit tests. Task 7 implements integration tests. Task 8 adds environment configuration.

- [x] Task 1: Define Interfaces and Data Models (AC: 1)
  - [x] Create `packages/connector/src/settlement/aptos-claim-signer.ts`
  - [x] Define `AptosClaim` interface with all fields (channelOwner, amount, nonce, signature, publicKey, createdAt)
  - [x] Define `AptosClaimSignerConfig` interface
  - [x] Define `ChannelClaimState` internal interface for tracking
  - [x] Define `IAptosClaimSigner` interface with all methods
  - [x] Export interfaces from module

- [x] Task 2: Implement BCS Message Encoding (AC: 4)
  - [x] Import `bcs` from @aptos-labs/ts-sdk
  - [x] Implement `constructClaimMessage(channelOwner, amount, nonce)` function
  - [x] Encode "CLAIM_APTOS" prefix as UTF-8 bytes
  - [x] BCS encode address as 32 bytes (using bcs.bytes(32))
  - [x] BCS encode amount as u64 (using bcs.u64())
  - [x] BCS encode nonce as u64 (using bcs.u64())
  - [x] Concatenate all parts in correct order
  - [x] Add unit test verifying deterministic output

- [x] Task 3: Implement signClaim Method (AC: 2, 3)
  - [x] Import Ed25519PrivateKey, Ed25519PublicKey from @aptos-labs/ts-sdk
  - [x] Implement AptosClaimSigner constructor
  - [x] Initialize Ed25519PrivateKey from config.privateKey
  - [x] Derive Ed25519PublicKey from private key
  - [x] Initialize channelStates Map
  - [x] Implement signClaim() method:
    - [x] Validate nonce > highest nonce for channel
    - [x] Construct message using constructClaimMessage()
    - [x] Sign message with privateKey.sign()
    - [x] Create AptosClaim object with all fields
    - [x] Log claim signing with structured logging (Pino)
  - [x] Implement getPublicKey() returning hex string

- [x] Task 4: Implement verifyClaim Method (AC: 5)
  - [x] Import Ed25519Signature from @aptos-labs/ts-sdk
  - [x] Implement verifyClaim() method:
    - [x] Construct message using constructClaimMessage()
    - [x] Parse signature using Ed25519Signature
    - [x] Parse publicKey using Ed25519PublicKey
    - [x] Call publicKey.verifySignature({ message, signature })
    - [x] Log verification result with structured logging
  - [x] Handle and log verification errors gracefully
  - [x] Return false for any verification failure (never throw)

- [x] Task 5: Implement Nonce and Claim State Tracking (AC: 6, 7, 8)
  - [x] Implement getHighestNonce(channelOwner) method (for signed claims)
  - [x] Implement getLatestClaim(channelOwner) method (for signed claims)
  - [x] Implement getChannelOwners() method
  - [x] Implement getHighestReceivedNonce(channelOwner, publicKey) method (for received claims)
  - [x] Add receivedClaimStates Map for tracking peer claims separately
  - [x] Add getReceivedClaimKey() helper for composite key generation
  - [x] Update signClaim() to:
    - [x] Check nonce > current highest nonce
    - [x] Throw AptosClaimError with INVALID_NONCE if nonce is invalid
    - [x] Update channelStates with new highest nonce
    - [x] Store latest claim in channelStates
  - [x] Update verifyClaim() to:
    - [x] Check nonce > highest received nonce from this peer (using composite key)
    - [x] Update receivedClaimStates on successful verification
    - [x] Log stale nonce warnings with peer public key

- [x] Task 6: Implement Unit Tests (AC: 9)
  - [x] Create `packages/connector/src/settlement/aptos-claim-signer.test.ts`
  - [x] Test signClaim() produces valid 64-byte signature
  - [x] Test signClaim() produces valid 32-byte public key
  - [x] Test signClaim() rejects nonce <= previous
  - [x] Test signClaim() tracks nonces independently per channel
  - [x] Test signClaim() stores latest claim
  - [x] Test verifyClaim() validates correct signature
  - [x] Test verifyClaim() rejects wrong amount
  - [x] Test verifyClaim() rejects wrong nonce
  - [x] Test verifyClaim() rejects stale nonce from same peer
  - [x] Test verifyClaim() handles malformed signature gracefully
  - [x] Test getPublicKey() returns consistent value
  - [x] Test getHighestNonce() returns correct value (signed claims)
  - [x] Test getHighestReceivedNonce() returns correct value (received claims)
  - [x] Test getLatestClaim() returns correct claim
  - [x] Test getChannelOwners() returns all channels
  - [x] Test BCS encoding produces deterministic bytes
  - [x] Test received claims tracked separately from signed claims
  - [x] Test same nonce allowed from different peers
  - [x] Achieve >80% code coverage

- [x] Task 7: Implement Integration Tests (AC: 10)
  - [x] Create `packages/connector/test/integration/aptos-claim-signer.test.ts`
  - [x] Add beforeAll hook checking APTOS_CLAIM_PRIVATE_KEY environment
  - [x] Skip tests gracefully if environment not configured
  - [x] Test: Sign claim and verify locally
  - [x] Test: Signature format matches expected ed25519 format
  - [x] Test: BCS encoding cross-validation with Move module (if verify_signature_view available)
  - [x] Document test prerequisites (module deployment, channel creation)
  - [x] Note: Full end-to-end test (sign → submit to chain → verify transfer) requires Story 13.4 SDK
  - [x] Note: Consider adding verify_signature_view function to Move module in future for BCS validation

- [x] Task 8: Add Environment Configuration (AC: 1)
  - [x] Update `packages/connector/.env.example` with APTOS_CLAIM_PRIVATE_KEY
  - [x] Add documentation comments explaining claim key vs account key
  - [x] (Optional) Implement createAptosClaimSignerFromEnv() factory function
    - [x] Follows pattern from Story 13.1 createAptosClientFromEnv()
    - [x] Reads APTOS_CLAIM_PRIVATE_KEY from environment
    - [x] Creates logger if not provided

## Testing

**Test Framework:** Jest 29.7.x with ts-jest
[Source: docs/architecture/test-strategy-and-standards.md]

**Test File Locations:**

- Unit tests: `packages/connector/src/settlement/aptos-claim-signer.test.ts`
- Integration tests: `packages/connector/test/integration/aptos-claim-signer.test.ts`

**Test Categories:**

1. **Unit Tests (Jest):**
   - Signature creation and format
   - Signature verification (valid and invalid)
   - Nonce tracking and validation
   - Claim state storage
   - BCS encoding determinism
   - Error handling

2. **Integration Tests:**
   - End-to-end claim flow with testnet
   - Signature format compatibility

**Running Tests:**

```bash
# Unit tests
cd packages/connector
npm test -- aptos-claim-signer.test.ts

# With coverage
npm test -- aptos-claim-signer.test.ts --coverage

# Integration tests (requires env vars)
npm test -- test/integration/aptos-claim-signer.test.ts
```

**Coverage Goals:**

- Unit test coverage: >80% (connector package standard)
- All public methods tested
- All error paths tested

## Change Log

| Date       | Version | Description                                                                                                                                                                                                                                                                                                                                                                                                  | Author     |
| ---------- | ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ---------- |
| 2026-01-30 | 0.1     | Initial draft created from Epic 13                                                                                                                                                                                                                                                                                                                                                                           | SM Agent   |
| 2026-01-30 | 0.2     | Validation fixes: (1) Clarified verifyClaim() uses separate tracking for received claims vs signed claims, (2) Added getHighestReceivedNonce() method, (3) Updated AC #10 to clarify Story 13.4 dependency for full e2e test, (4) Added AptosClaimError class with error codes, (5) Added BCS cross-validation integration test, (6) Added ReceivedClaimState interface, (7) Added missing template sections | Validation |

## Dev Agent Record

### Agent Model Used

Claude Opus 4.5 (claude-opus-4-5-20251101)

### Debug Log References

No issues requiring debug log entries.

### Completion Notes

- Implemented `AptosClaimSigner` class with full ed25519 signing/verification using @aptos-labs/ts-sdk
- BCS encoding matches Move module format: `"CLAIM_APTOS" || address (32 bytes) || amount (u64) || nonce (u64)`
- Separate tracking for signed claims (`channelStates`) vs received claims from peers (`receivedClaimStates`)
- Nonce tracking uses composite key `channelOwner:peerPublicKey` for received claims
- Test coverage: 100% statements, 100% functions, 90.9% branches (exceeds 80% requirement)
- 52 unit tests + 10 integration tests = 62 total tests passing
- Factory function `createAptosClaimSignerFromEnv()` implemented for environment-based configuration
- All settlement tests pass (553 tests) confirming no regression

### File List

| File                                                             | Action   | Description                                                              |
| ---------------------------------------------------------------- | -------- | ------------------------------------------------------------------------ |
| `packages/connector/src/settlement/aptos-claim-signer.ts`        | Created  | Main implementation with interfaces, BCS encoding, signing, verification |
| `packages/connector/src/settlement/aptos-claim-signer.test.ts`   | Created  | Unit tests (52 tests)                                                    |
| `packages/connector/test/integration/aptos-claim-signer.test.ts` | Created  | Integration tests (10 tests)                                             |
| `packages/connector/.env.example`                                | Modified | Added APTOS_CLAIM_PRIVATE_KEY and APTOS_MODULE_ADDRESS                   |

## QA Results

### Review Date: 2026-01-30

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

The implementation is high quality with clean architecture and comprehensive testing. The `AptosClaimSigner` class properly implements the `IAptosClaimSigner` interface with:

- **Well-structured code**: Clear separation between interfaces, data models, BCS encoding, and implementation
- **Proper cryptography**: Uses @aptos-labs/ts-sdk Ed25519 primitives correctly
- **Strong error handling**: Custom `AptosClaimError` class with typed error codes
- **Correct BCS encoding**: Message format matches Move module expectations (CLAIM_APTOS || address || amount || nonce)
- **Separate state tracking**: Properly separates signed claims (`_channelStates`) from received claims (`_receivedClaimStates`)

### Refactoring Performed

No refactoring performed - implementation already meets quality standards.

### Compliance Check

- Coding Standards: ✓ Uses Pino logger, private member naming convention, TypeScript strict mode
- Project Structure: ✓ Co-located tests, proper file organization in settlement module
- Testing Strategy: ✓ Unit tests (52) + Integration tests (10), exceeds 80% coverage
- All ACs Met: ✓ All 10 acceptance criteria verified and implemented

### Improvements Checklist

- [x] All acceptance criteria implemented
- [x] Unit test coverage: 100% statements, 100% functions, 90.9% branches
- [x] Integration tests validate local signing/verification
- [x] Environment configuration documented in .env.example
- [x] Factory function createAptosClaimSignerFromEnv() implemented
- [ ] Consider adding AIP-80 compliant key formatting to suppress SDK warnings (future enhancement)
- [ ] Consider persisting nonce state to disk for crash recovery (future enhancement per story notes)

### Security Review

- **Key Isolation**: ✓ APTOS_CLAIM_PRIVATE_KEY separate from APTOS_PRIVATE_KEY
- **Key Handling**: ✓ Private keys never logged, only read from environment
- **Nonce Tracking**: ✓ Prevents replay attacks with per-channel, per-peer nonce tracking
- **Signature Format**: ✓ Standard ed25519 (64-byte signatures, 32-byte public keys)

### Performance Considerations

- All operations are synchronous and lightweight
- BCS encoding uses efficient byte manipulation
- Map-based state lookups are O(1)

### Files Modified During Review

None - no modifications required.

### Gate Status

Gate: PASS → docs/qa/gates/27.3-off-chain-claim-signing.yml

### Recommended Status

✓ Ready for Done
