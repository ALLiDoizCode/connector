# Story 25.2: Clean ConnectorNode Lifecycle Methods

## Status

Done

## Story

**As a** library consumer,
**I want** `ConnectorNode.start()` and `stop()` to be clean and reentrant,
**so that** I can safely manage connector lifecycle within my own process without unexpected exit behavior.

## Acceptance Criteria

1. Zero `process.exit()` calls in `ConnectorNode`, `AdminServer`, or any non-CLI code
2. Zero `process.on(signal)` calls in library code
3. `start()` throws on failure (not exits) — caller handles the error
4. `stop()` is idempotent — safe to call multiple times
5. `start()` → `stop()` → `start()` works (reentrant)
6. BTP connections, AdminServer, SettlementMonitor all shut down gracefully on `stop()`
7. All existing lifecycle tests pass
8. New tests for reentrant lifecycle and error propagation

## Tasks / Subtasks

- [x] Task 1: Audit and verify zero `process.exit()` and `process.on()` in library code (AC: 1, 2)
  - [x] 1.1 Grep `packages/connector/src/` for `process.exit` excluding `main.ts` and `cli/` — verify zero matches in executable code (JSDoc examples in `config-loader.ts` line 79 and `topology-validator.ts` lines 70 and 343 are acceptable — they are comments, not executable code)
  - [x] 1.2 Grep `packages/connector/src/` for `process.on(` excluding `main.ts` and `cli/` — verify zero matches
  - [x] 1.3 Grep `packages/connector/src/` for `process.once(` excluding `main.ts` and `cli/` — verify zero matches
  - [x] 1.4 Verify `ConnectorNode.start()` throws on failure at line 979 (`throw error`) — confirmed, no `process.exit()` in start()
  - [x] 1.5 Verify `ConnectorNode.stop()` throws on failure at line 1077 (`throw error`) — confirmed, no `process.exit()` in stop()
  - [x] 1.6 Verify `AdminServer.start()` rejects with Error on port conflict (line 194 `reject(new Error(...))`) — no `process.exit()`
  - [x] 1.7 Verify `AdminServer.stop()` rejects on close failure (line 245 `reject(error)`) — no `process.exit()`
  - [x] 1.8 Document findings — if all pass, no code changes needed for AC 1, 2, 3

- [x] Task 2: Fix `ConnectorNode.stop()` to shut down SettlementMonitor and SettlementExecutor (AC: 6)
  - [x] 2.1 In `packages/connector/src/core/connector-node.ts` `stop()` method, add shutdown of `_settlementExecutor` BEFORE `_channelManager` shutdown. Call `this._settlementExecutor.stop()` and set to null. The executor's `stop()` is synchronous (calls `this.monitor.off(...)` internally).
    ```typescript
    // Stop settlement executor if running (before channel manager)
    if (this._settlementExecutor) {
      this._settlementExecutor.stop();
      this._logger.info({ event: 'settlement_executor_stopped' }, 'Settlement executor stopped');
      this._settlementExecutor = null;
    }
    ```
  - [x] 2.2 Add shutdown of `_settlementMonitor` AFTER `_settlementExecutor`. Call `await this._settlementMonitor.stop()` and set to null. The monitor's `stop()` clears the polling interval.
    ```typescript
    // Stop settlement monitor if running (after executor)
    if (this._settlementMonitor) {
      await this._settlementMonitor.stop();
      this._logger.info({ event: 'settlement_monitor_stopped' }, 'Settlement monitor stopped');
      this._settlementMonitor = null;
    }
    ```
  - [x] 2.3 Add shutdown of `_accountManager` — set to null (no explicit close method, but TigerBeetleClient has `close()`). Since `_accountManager` wraps TigerBeetleClient, ensure the TigerBeetleClient is also closed. Note: TigerBeetleClient is created locally in `start()` at line 437 and not stored as a class field — add `private _tigerBeetleClient: TigerBeetleClient | null = null` class field, then assign `this._tigerBeetleClient = tigerBeetleClient` immediately after `await tigerBeetleClient.initialize()` (after line 448), and close it in `stop()`.
    ```typescript
    // Close TigerBeetle client if connected
    if (this._tigerBeetleClient) {
      await this._tigerBeetleClient.close();
      this._logger.info({ event: 'tigerbeetle_client_closed' }, 'TigerBeetle client closed');
      this._tigerBeetleClient = null;
    }
    this._accountManager = null;
    ```
  - [x] 2.4 Verify shutdown order in `stop()` is: SettlementExecutor → SettlementMonitor → AptosChannelSDK → ChannelManager → PaymentChannelSDK → TigerBeetleClient (active close) → AccountManager (null cleanup only — no close method) → ExplorerServer → EventStore → TelemetryEmitter → BTP Clients → AdminServer → HealthServer → BTP Server

- [x] Task 3: Make `stop()` idempotent — safe to call multiple times (AC: 4)
  - [x] 3.1 Add an early return guard at the top of `stop()`: if `_btpServerStarted` is already false AND all nullable components are null, return immediately without logging or doing work. This makes calling `stop()` on an already-stopped connector a no-op.
    ```typescript
    // Idempotent guard: if already stopped, return immediately
    if (!this._btpServerStarted && !this._adminServer && !this._explorerServer) {
      this._logger.debug(
        { event: 'connector_already_stopped' },
        'Connector already stopped, ignoring'
      );
      return;
    }
    ```
  - [x] 3.2 Verify each sub-component's `stop()` is already idempotent:
    - `BTPServer.stop()`: checks `if (!this.wss) return` — ✓ idempotent [Source: packages/connector/src/btp/btp-server.ts:114]
    - `HealthServer.stop()`: checks `if (!this._server) return` — ✓ idempotent [Source: packages/connector/src/http/health-server.ts:318]
    - `AdminServer.stop()`: checks `if (!this._server) return` — ✓ idempotent [Source: packages/connector/src/http/admin-server.ts:231]
    - `SettlementMonitor.stop()`: clears interval if exists, sets `_isRunning = false` — ✓ idempotent [Source: packages/connector/src/settlement/settlement-monitor.ts:197]
    - `SettlementExecutor.stop()`: calls `this.monitor.off(...)` — no guard, but `off()` with same handler twice is safe — ✓ idempotent [Source: packages/connector/src/settlement/unified-settlement-executor.ts:172-176]
    - `ExplorerServer.stop()`: checks `if (!this._started) return` — ✓ idempotent [Source: packages/connector/src/explorer/explorer-server.ts:469]
    - `EventStore.close()`: checks `if (this._client)` before closing, sets `_client = null` — ✓ idempotent [Source: packages/connector/src/explorer/event-store.ts:679-685]

- [x] Task 4: Make `start()` → `stop()` → `start()` reentrant (AC: 5)
  - [x] 4.1 Review `stop()` to ensure all state is reset for re-start:
    - `_btpServerStarted = false` — ✓ reset at line 1096
    - `_healthStatus = 'starting'` — ✓ reset at line 1095
    - `_adminServer = null` — ✓ set in stop()
    - `_explorerServer = null` — ✓ set in stop()
    - `_eventStore = null` — ✓ set in stop()
    - `_aptosChannelSDK = null` — ✓ set in stop()
    - `_channelManager = null` — ✓ set in stop()
    - `_paymentChannelSDK = null` — ✓ set in stop()
    - `_settlementExecutor = null` — ✓ set in stop() (Task 2)
    - `_settlementMonitor = null` — ✓ set in stop() (Task 2)
    - `_accountManager = null` — ✓ set in stop() (Task 2)
    - `_tigerBeetleClient = null` — ✓ set in stop() (Task 2)
  - [x] 4.2 Verify `start()` creates fresh instances of all components — it does: BTPServer.start(), HealthServer.start(), AdminServer constructor + start(), etc. are all called in start(). The RoutingTable, BTPClientManager, PacketHandler, and BTPServer are created in the constructor (not start), so they persist across start/stop cycles. This is acceptable — they hold no connection state that would prevent re-start.
  - [x] 4.3 Verify BTPServer can be started again after stop — `BTPServer.start()` calls `new WebSocketServer(...)` which creates a fresh WSS instance. After `stop()` sets `this.wss = null`, a subsequent `start()` will create a new WSS. ✓ reentrant.
  - [x] 4.4 Verify HealthServer can be started again after stop — `HealthServer.start()` calls `this._app.listen(...)` creating a new server. After `stop()` sets `_server = null`, a subsequent `start()` creates a new server. ✓ reentrant.

- [x] Task 5: Add new unit tests for lifecycle behaviors (AC: 4, 5, 7, 8)
  - [x] 5.1 In `packages/connector/src/core/connector-node.test.ts`, add a new `describe('Lifecycle — reentrant and idempotent')` block with the following tests:
  - [x] 5.2 Test: `stop() is idempotent — calling stop() twice does not throw` — call `stop()` twice in sequence, verify no error thrown and both calls resolve
  - [x] 5.3 Test: `stop() on never-started connector does not throw` — create ConnectorNode but don't call start(), call stop(), verify it returns without error
  - [x] 5.4 Test: `start() → stop() → start() lifecycle works (reentrant)` — start connector, stop it, start it again, verify via `getHealthStatus()` returning `'healthy'` after second start (public API — do not access private `_btpServerStarted` field)
  - [x] 5.5 Test: `start() throws on BTP server failure and sets health to unhealthy` — mock BTPServer.start() to throw, verify start() rejects, verify health status is 'unhealthy'
  - [x] 5.6 Test: `stop() shuts down SettlementMonitor when active` — enable settlement in config/mocks, call start(), then stop(), verify SettlementMonitor.stop() was called
  - [x] 5.7 Test: `stop() shuts down SettlementExecutor when active` — verify SettlementExecutor.stop() was called during stop()
  - [x] 5.8 Test: `stop() closes TigerBeetle client when connected` — verify TigerBeetleClient.close() was called during stop()
  - [x] 5.9 Test: `stop() shuts down SettlementExecutor before ChannelManager` — use mock call order tracking (`jest.fn()` with shared call log) to verify SettlementExecutor.stop() is called before ChannelManager shutdown, ensuring no dangling event listeners fire during channel teardown

- [x] Task 6: Run full test suite and verify no regressions (AC: 7)
  - [x] 6.1 Run `npm test --workspace=@agent-runtime/connector` — 126/129 suites pass (3 pre-existing perf/timing failures, same as Story 25.1)
  - [x] 6.2 Specifically verify `connector-node.test.ts` — 75 tests pass (67 existing + 8 new lifecycle tests)
  - [x] 6.3 Run shared package tests — 4/5 suites pass (1 pre-existing perf failure), no cross-package regressions
  - [x] 6.4 Verify TypeScript compilation: `npx tsc --project packages/connector/tsconfig.json --noEmit` — passes cleanly

## Dev Notes

### Epic Context

This is the second story in Epic 25 (CLI/Library Separation & Lifecycle Cleanup). Story 25.1 (Split Library Exports from Process Entrypoint) is complete — `lib.ts` contains pure re-exports, `main.ts` owns all process lifecycle, and `index.ts` is a barrel re-export. This story focuses on ensuring the `ConnectorNode` class itself has clean, reentrant lifecycle methods.

Epic 25 stories:

- **25.1** (Done): Split library exports from process entrypoint
- **25.2** (this story): Clean ConnectorNode lifecycle methods
- **25.3**: Export all composition types
  [Source: docs/prd/epic-25-cli-library-separation.md]

### Previous Story Insights (Story 25.1)

- `lib.ts` is pure re-exports, zero side effects — verified by grep
- `main.ts` contains all `process.exit()` and signal handlers
- `index.ts` reduced to `export * from './lib'`
- Connector tests: 125 suites passed, 2531 tests. 4 pre-existing failures (performance/timing)
- `ConfigLoader` removed from `main.ts` import — unused (TS strict caught it)
  [Source: docs/stories/25.1.story.md#dev-agent-record]

### Current `ConnectorNode.start()` Analysis

`ConnectorNode.start()` (line 285-981 in `connector-node.ts`) is already clean:

- **No `process.exit()` calls** — on failure, throws error at line 979
- **No signal handler registration** — signal handlers are only in `main.ts`
- Error propagation: wraps entire body in try-catch, logs error, sets health to 'unhealthy', re-throws
- Graceful degradation: Aptos SDK, payment channels, explorer, telemetry all fail gracefully (log + continue)
  [Source: packages/connector/src/core/connector-node.ts:285-981]

### Current `ConnectorNode.stop()` Analysis

`ConnectorNode.stop()` (line 987-1079) is mostly clean but has **two gaps**:

1. **Missing SettlementExecutor shutdown** — `_settlementExecutor.start()` is called in `start()` (line 556) but `_settlementExecutor.stop()` is never called in `stop()`. This leaves the executor's event listener on SettlementMonitor active after stop.
2. **Missing SettlementMonitor shutdown** — `settlementMonitor.start()` is called in `start()` (line 565, via setTimeout) but never stopped in `stop()`. This leaves the polling interval running.
3. **Missing TigerBeetleClient close** — TigerBeetleClient is created in `start()` (line 437-445) but the reference is not stored as a class field, so it cannot be closed in `stop()`. Need to add `private _tigerBeetleClient: TigerBeetleClient | null = null` field.
4. **Not idempotent** — calling `stop()` twice will attempt to stop BTPServer and HealthServer again (though their individual stop methods are idempotent, the parent `stop()` does unnecessary work and logs redundant events)

Current shutdown order in `stop()`:

```
AptosChannelSDK → ChannelManager → PaymentChannelSDK → ExplorerServer → EventStore → TelemetryEmitter → BTP Clients → AdminServer → HealthServer → BTP Server
```

Required shutdown order (after fix):

```
SettlementExecutor → SettlementMonitor → AptosChannelSDK → ChannelManager → PaymentChannelSDK → TigerBeetleClient (active close) → AccountManager (null cleanup only) → ExplorerServer → EventStore → TelemetryEmitter → BTP Clients → AdminServer → HealthServer → BTP Server
```

[Source: packages/connector/src/core/connector-node.ts:987-1079]

### AdminServer Lifecycle

`AdminServer.start()` and `stop()` are already clean:

- `start()`: Rejects with Error on port conflict (`EADDRINUSE`), no `process.exit()`
- `stop()`: Idempotent — checks `if (!this._server) return` before closing
- No signal handlers or `process.exit()` calls anywhere in the class
  [Source: packages/connector/src/http/admin-server.ts:151-258]

### Sub-component Stop Idempotency

All sub-components already have idempotent `stop()` methods:

- `BTPServer.stop()`: `if (!this.wss) return` guard [Source: btp-server.ts:114]
- `HealthServer.stop()`: `if (!this._server) return` guard [Source: health-server.ts:318]
- `AdminServer.stop()`: `if (!this._server) return` guard [Source: admin-server.ts:231]
- `SettlementMonitor.stop()`: `clearInterval` on null-checked `_pollingIntervalId` [Source: settlement-monitor.ts:197-205]
- `SettlementExecutor.stop()`: no explicit guard, but calls `monitor.off()` which is safe to call multiple times [Source: unified-settlement-executor.ts:172-176]
- `ExplorerServer.stop()`: `if (!this._started) return` guard, sets `_started = false` after cleanup [Source: explorer-server.ts:468-504]
- `EventStore.close()`: `if (this._client)` guard, sets `_client = null` after close [Source: event-store.ts:679-685]

### Existing Test Coverage

`connector-node.test.ts` has 67+ tests organized in these describe blocks:

- Constructor (7 tests)
- start() (5 tests) — includes BTP server start, client connections, logging, health status
- stop() (5 tests) — includes client disconnect, server stop order, logging, status reset
- getHealthStatus() (10 tests)
- Object-based Construction (6 tests)
- setLocalDeliveryHandler() (4 tests)
- sendPacket() (8 tests)
- getRoutingTable() (1 test)
- admin operations (20+ tests)

**Missing tests** (to be added in this story):

- stop() idempotency (calling twice)
- stop() on never-started connector
- start() → stop() → start() reentrant cycle
- SettlementMonitor/Executor shutdown during stop()
- TigerBeetleClient close during stop()
  [Source: packages/connector/src/core/connector-node.test.ts]

### Coding Standards

- TypeScript strict mode, no `any` types except in test mocks [Source: docs/architecture/coding-standards.md]
- File naming: kebab-case [Source: docs/architecture/coding-standards.md]
- Pino logger exclusively (no `console.log`) [Source: docs/architecture/coding-standards.md]
- All async functions must handle errors with try-catch [Source: docs/architecture/coding-standards.md]

### Testing

- **Framework:** Jest 29.7.x with `ts-jest` [Source: docs/architecture/tech-stack.md]
- **File Convention:** Co-located `<filename>.test.ts` next to source [Source: docs/architecture/coding-standards.md]
- **Pattern:** AAA (Arrange, Act, Assert) with descriptive test names
- **Mocking:** Jest built-in (`jest.fn()`, `jest.mock()`)
- **Coverage Requirement:** >80% line coverage for connector package
- **Anti-patterns to avoid:** inline `bind(this)`, insufficient async timeouts, mock state leakage
  [Source: docs/architecture/test-strategy-and-standards.md]

### Project Structure Notes

No structural conflicts. This story modifies only existing files:

```
packages/connector/src/
├── core/
│   ├── connector-node.ts      # MODIFIED — add settlement shutdown, idempotent stop, TigerBeetle field
│   └── connector-node.test.ts # MODIFIED — add lifecycle tests
```

No new files are created. Changes are isolated to `ConnectorNode` class internals and its tests.

## Dev Agent Record

### Agent Model Used

Claude Opus 4.6

### File List

| File                                                 | Action   | Description                                                                                                                                                                                               |
| ---------------------------------------------------- | -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `packages/connector/src/core/connector-node.ts`      | Modified | Added `_tigerBeetleClient` field, stored TB client ref in `start()`, added SettlementExecutor/SettlementMonitor/TigerBeetleClient/AccountManager shutdown to `stop()`, added idempotent guard to `stop()` |
| `packages/connector/src/core/connector-node.test.ts` | Modified | Updated `stop()` describe beforeEach to start connector first (for idempotent guard compatibility), added 8 new lifecycle tests in `describe('Lifecycle — reentrant and idempotent')`                     |

### Debug Log References

None — no blocking issues encountered.

### Completion Notes

- All 6 tasks completed. 75/75 connector-node tests pass (67 existing + 8 new).
- Pre-existing failures in btp-client.test.ts, wallet-derivation.test.ts, and oer.perf.test.ts are unchanged (performance/timing, same as Story 25.1).
- TypeScript compilation clean. No new files created — changes isolated to ConnectorNode class and its tests.
- The `stop()` describe block's `beforeEach` was updated from sync to async and now calls `start()` before testing `stop()`, since the new idempotent guard short-circuits when the connector was never started.

## Change Log

| Date       | Version | Description                                                                                                                                                                                      | Author        |
| ---------- | ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------- |
| 2026-02-11 | 1.0     | Initial story creation                                                                                                                                                                           | Scrum Master  |
| 2026-02-11 | 1.1     | Validation fixes: verified ExplorerServer/EventStore idempotency, added source refs for all sub-components, clarified AccountManager cleanup vs active shutdown, added shutdown order test       | QA Validation |
| 2026-02-11 | 1.2     | Fix Task 1.1 process.exit JSDoc ref (topology-validator.ts not config-loader.ts line 343), add TigerBeetleClient field insertion point in Task 2.3, use public getHealthStatus() API in Task 5.4 | QA Validation |

## QA Results

### Review Date: 2026-02-11

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

High-quality implementation. The `stop()` method changes are clean, well-ordered, and follow the existing code patterns precisely. The idempotent guard is sound, the shutdown ordering (SettlementExecutor → SettlementMonitor → AptosChannelSDK → ChannelManager → PaymentChannelSDK → TigerBeetleClient → AccountManager → ExplorerServer → EventStore → TelemetryEmitter → BTP Clients → AdminServer → HealthServer → BTP Server) is correct and respects dependency relationships. The `_tigerBeetleClient` field addition is the right approach to retain the reference for cleanup.

The new lifecycle tests are well-structured, use AAA pattern, and cover the important edge cases (double-stop, never-started stop, reentrant cycle, component shutdown verification, shutdown ordering). The use of `callOrder` tracking in the executor-before-channel-manager test is a clean pattern for verifying ordering.

### Refactoring Performed

None — implementation is clean as-is.

### Compliance Check

- Coding Standards: ✓ TypeScript strict mode, Pino logger, kebab-case files, async error handling
- Project Structure: ✓ Co-located tests, no new files created, changes isolated to ConnectorNode
- Testing Strategy: ✓ AAA pattern, Jest mocks, descriptive test names, 8 new tests covering all new behaviors
- All ACs Met: ✓ All 8 acceptance criteria verified (see traceability below)

### AC Traceability

| AC  | Requirement                               | Verified By                                                                                   | Status |
| --- | ----------------------------------------- | --------------------------------------------------------------------------------------------- | ------ |
| 1   | Zero `process.exit()` in non-CLI code     | Grep audit: 3 matches all JSDoc comments in config-loader.ts:79, topology-validator.ts:70,343 | ✓      |
| 2   | Zero `process.on(signal)` in library code | Grep audit: 0 matches outside main.ts                                                         | ✓      |
| 3   | `start()` throws on failure               | connector-node.ts:979 throws error; test "start() throws on BTP server failure"               | ✓      |
| 4   | `stop()` is idempotent                    | Idempotent guard at line 991; tests "stop() twice" and "stop() on never-started"              | ✓      |
| 5   | `start()→stop()→start()` reentrant        | State reset at lines 1095-1096; test "start()→stop()→start() lifecycle works"                 | ✓      |
| 6   | All components shut down on `stop()`      | Lines 1005-1046; tests for SettlementMonitor, Executor, TigerBeetleClient shutdown            | ✓      |
| 7   | All existing lifecycle tests pass         | 67 existing + 8 new = 75/75 pass                                                              | ✓      |
| 8   | New tests for reentrant/idempotent        | 8 new tests in "Lifecycle — reentrant and idempotent" describe block                          | ✓      |

### Improvements Checklist

- [x] All acceptance criteria implemented and tested
- [x] Shutdown order verified correct (executor before monitor before channel manager)
- [x] Sub-component idempotency audited (all have guards)
- [ ] **CONCERN (low):** Idempotent guard checks `_btpServerStarted`, `_adminServer`, `_explorerServer` but not `_settlementMonitor`, `_settlementExecutor`, `_tigerBeetleClient`, `_channelManager`, `_paymentChannelSDK`. In practice this is safe because those components are only created during `start()` which also sets `_btpServerStarted=true`, so the guard catches all cases. However, if a future change initializes settlement components outside of `start()`, the guard would miss them. Consider adding a single `_isRunning` boolean flag for a more robust guard. This is a **future** improvement, not a blocker.
- [ ] **CONCERN (low):** `_telemetryEmitter` is `readonly` (line 75) and never set to `null` in `stop()` — `.disconnect()` is called but the reference persists. This is fine because `TelemetryEmitter.disconnect()` is idempotent and `start()` checks telemetry config, not the field value. However, for consistency with other nullable components, this could be made non-readonly and nulled in `stop()`. Not a blocker — existing behavior is correct.

### Security Review

No security concerns. This story removes process-level side effects from library code, which is a security improvement (prevents unexpected process termination by library consumers).

### Performance Considerations

No performance concerns. The idempotent guard is O(1) — three null/boolean checks. Shutdown order change adds no overhead.

### Files Modified During Review

None — no refactoring performed.

### Gate Status

Gate: PASS → docs/qa/gates/25.2-clean-connectornode-lifecycle-methods.yml

### Recommended Status

✓ Ready for Done
