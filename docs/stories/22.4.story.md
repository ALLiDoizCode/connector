# Story 22.4: Validate BLS Response Data Before FULFILL Pass-Through

**Epic:** 22 - Agent-Runtime Middleware Simplification
**Story Number:** 22.4
**Status:** Done
**Priority:** P2 (Medium — Safety)

## Story

**As a** connector operator,
**I want** the agent-runtime middleware to validate BLS response data before passing it into ILP FULFILL packets,
**so that** malformed or oversized data from the BLS doesn't produce invalid ILP packets that the connector rejects or propagates to peers.

## Acceptance Criteria

1. BLS `response.data` validated as valid base64 before inclusion in FULFILL (Gap 15)
2. Invalid base64 data is omitted from FULFILL with a warning log (not a hard error — the payment still fulfills)
3. Decoded data size validated against ILP maximum (32,768 bytes / 32KB)
4. Oversized data is omitted from FULFILL with a warning log
5. `null`, `undefined`, or empty string `response.data` passed through as-is (no validation needed — all are falsy, so `if (!data)` short-circuits)
6. Same validation applied to REJECT response data pass-through
7. Validation function is a pure, testable utility: `validateIlpResponseData(data: string | undefined, logger: Logger): string | undefined`
8. Unit tests for valid base64 pass-through, invalid base64 omission, oversized data omission, absent data pass-through
9. No change to the fulfillment computation (`SHA256(data)` remains unchanged — this validates the BLS response data, not the PREPARE data)
10. All existing packet handler tests continue to pass

## Tasks / Subtasks

- [x] Task 1: Create data validation utility (AC: 1, 2, 3, 4, 5, 7)
  - [x] Add `validateIlpResponseData()` function in `packages/agent-runtime/src/packet/packet-handler.ts` (or a separate utility file if preferred):

    ```typescript
    function validateIlpResponseData(data: string | undefined, logger: Logger): string | undefined {
      if (!data) return data; // null/undefined/empty pass through

      // Validate base64
      try {
        const decoded = Buffer.from(data, 'base64');
        // Verify round-trip (catches non-base64 strings that Buffer.from silently decodes)
        if (decoded.toString('base64') !== data) {
          logger.warn('BLS response data is not valid base64, omitting from ILP response');
          return undefined;
        }
        // Validate size
        if (decoded.length > 32768) {
          logger.warn(
            { size: decoded.length, limit: 32768 },
            'BLS response data exceeds 32KB ILP limit, omitting from ILP response'
          );
          return undefined;
        }
        return data;
      } catch {
        logger.warn('BLS response data failed base64 decode, omitting from ILP response');
        return undefined;
      }
    }
    ```

- [x] Task 2: Apply validation in FULFILL path (AC: 1, 2, 3, 4, 9)
  - [x] In `packet-handler.ts` FULFILL path (line 86):
    - [x] Change `data: response.data` to `data: validateIlpResponseData(response.data, this.logger)`
    - [x] Ensure this does NOT affect the fulfillment computation — `computeFulfillmentFromData()` on line 79 operates on the inbound PREPARE `request.data`, not the BLS `response.data`

- [x] Task 3: Apply validation in REJECT path (AC: 6)
  - [x] In `packet-handler.ts` REJECT path (line 98):
    - [x] Change `this.reject(ilpCode, message, response.data)` to `this.reject(ilpCode, message, validateIlpResponseData(response.data, this.logger))`

- [x] Task 4: Write unit tests (AC: 8, 10)
  - [x] Create or update `packages/agent-runtime/src/packet/packet-handler.test.ts`:
    - [x] Test: valid base64 data passes through unchanged
    - [x] Test: invalid base64 data (e.g., `"not-valid-!!!base64"`) → returns undefined + warning log
    - [x] Test: oversized data (> 32KB decoded) → returns undefined + warning log
    - [x] Test: `undefined` data → returns undefined (no validation)
    - [x] Test: `null` data → returns null (no validation)
    - [x] Test: empty string `""` → returns `""` (falsy, so `if (!data)` short-circuits before validation)
    - [x] Test: exactly 32KB data → passes through (boundary: `Buffer.alloc(32768).toString('base64')`)
    - [x] Test: 32KB + 1 byte data → omitted (boundary: `Buffer.alloc(32769).toString('base64')`)
    - [x] Test: validation applied in both FULFILL and REJECT paths
  - [x] Verify existing packet handler tests still pass

## Dev Notes

### Gap Context

This story addresses 1 integration gap from `INTEGRATION-GAPS.md`:

- **Gap 15 (P2):** No validation of BLS `response.data` before passing into ILP FULFILL/REJECT packets. The packet-handler passes through `response.data` blindly. If the BLS returns malformed data, the ILP packet will be invalid.

### Key File Locations

| Action     | File                                                       | Lines                                            |
| ---------- | ---------------------------------------------------------- | ------------------------------------------------ |
| **Modify** | `packages/agent-runtime/src/packet/packet-handler.ts`      | 77-88 (FULFILL), 98 (REJECT via `this.reject()`) |
| **Modify** | `packages/agent-runtime/src/packet/packet-handler.test.ts` | Add validation-specific test cases               |

### Current Code

```typescript
// packet-handler.ts lines 77-88 — FULFILL path
if (response.accept) {
  const fulfillment = computeFulfillmentFromData(Buffer.from(request.data, 'base64'));

  return {
    fulfill: {
      fulfillment: fulfillment.toString('base64'),
      data: response.data, // ← passes BLS data blindly
    },
  };
}

// packet-handler.ts line 98 — REJECT path (passes data into this.reject() helper)
return this.reject(ilpCode, message, response.data); // ← also passes BLS data blindly
```

### Important Distinction

- **Fulfillment computation** uses the inbound PREPARE `request.data` (from the sender) — this is NOT being changed
- **Response data validation** applies to the outbound `response.data` from the BLS — this is what the BLS includes as application-level response data in the FULFILL/REJECT packet
- These are two different `data` fields:
  - `request.data` → input to `computeFulfillmentFromData()` (sender's TOON payload)
  - `response.data` → BLS's response payload passed through in FULFILL/REJECT (receiver's TOON reply)

### ILP Data Size Limits

Per ILPv4 (RFC-0027), the data field in ILP packets has a maximum size of 32,768 bytes (32KB). The connector enforces this for PREPARE packets but the middleware should also enforce it for FULFILL/REJECT data to prevent packet corruption downstream.

### Technical Constraints

- TypeScript strict mode — no `any` types
- Pino logger only — no `console.log`
- Buffer for binary data
- Pure function for testability
- No change to fulfillment computation logic

### Testing

**Framework:** Jest 29.7.x with ts-jest
**Convention:** Co-located `*.test.ts` next to source
**Coverage:** >80% line coverage
**Pattern:** AAA (Arrange, Act, Assert)
**Mock Strategy:** Mock Pino logger to verify warning calls

## Change Log

| Date       | Version | Description                                                                                           | Author     |
| ---------- | ------- | ----------------------------------------------------------------------------------------------------- | ---------- |
| 2026-02-09 | 1.0     | Initial story draft from INTEGRATION-GAPS.md (Gap 15)                                                 | Sarah (PO) |
| 2026-02-09 | 1.1     | Validation fixes: consistent function name in AC 7, precise line refs, test data hints, stub sections | QA         |

## Dev Agent Record

### Agent Model Used

Claude Opus 4.6

### Debug Log References

No debug issues encountered.

### Completion Notes List

- Added exported `validateIlpResponseData()` pure utility function to `packet-handler.ts`
- Function validates base64 encoding via round-trip check and enforces 32KB ILP data size limit (RFC-0027)
- Applied validation in both FULFILL path (line 125) and REJECT path (line 137)
- Fulfillment computation (`computeFulfillmentFromData`) is unaffected — it still operates on inbound `request.data`
- Updated two existing tests that used non-base64 BLS response data strings — they now use valid base64 to match the new validation behavior
- All 21 packet-handler tests pass, 102 total agent-runtime tests pass with zero regressions
- No new dependencies added

### File List

| Action       | File                                                       |
| ------------ | ---------------------------------------------------------- |
| **Modified** | `packages/agent-runtime/src/packet/packet-handler.ts`      |
| **Modified** | `packages/agent-runtime/src/packet/packet-handler.test.ts` |

### Change Log

| Date       | Version | Description                                                                                | Author      |
| ---------- | ------- | ------------------------------------------------------------------------------------------ | ----------- |
| 2026-02-09 | 1.2     | Implementation complete — validation utility, FULFILL/REJECT integration, 21 tests passing | James (Dev) |

## QA Results

### Review Date: 2026-02-09

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

Excellent implementation. The `validateIlpResponseData()` utility is clean, well-documented, and correctly placed as an exported pure function at module scope in `packet-handler.ts`. The implementation follows the story spec precisely with a round-trip base64 check (catches `Buffer.from`'s lenient decoding), a 32KB size check per RFC-0027, and a catch-all for decode errors. The function is applied in both FULFILL and REJECT paths as required.

Key quality observations:

- **Pure function design**: Stateless, deterministic, easily testable — matches AC 7 exactly
- **Graceful degradation**: Invalid data is omitted (returns `undefined`) rather than failing the payment — correct design for a pass-through field
- **Structured logging**: Oversized warning uses Pino's object-first pattern `{ size, limit }` for structured log aggregation; base64 warnings use simple strings — consistent with project conventions
- **No fulfillment impact**: `computeFulfillmentFromData()` on line 118 still operates on `request.data` (inbound PREPARE), completely independent of the validated `response.data` (outbound BLS reply). AC 9 satisfied.
- **Existing tests updated correctly**: Two pre-existing tests that used raw strings as BLS response data (`'bls-fulfill-data'`, `'rejection-details'`) were converted to valid base64 — necessary since the new validation would have silently stripped them.

### Refactoring Performed

No refactoring required. The implementation is clean and follows project patterns.

### Compliance Check

- Coding Standards: ✓ — TypeScript strict mode, Pino logger only, `Buffer` for binary, camelCase functions, UPPER_SNAKE_CASE constant (`ILP_MAX_DATA_BYTES`), co-located tests, no `any` types
- Project Structure: ✓ — Co-located `*.test.ts` next to source, validation utility in the file where it's used (not over-abstracted)
- Testing Strategy: ✓ — 95.12% line coverage on `packet-handler.ts`, 92.85% branch coverage. 8 dedicated unit tests for the validation function + 2 integration-level tests verifying FULFILL/REJECT paths. AAA pattern followed. Jest mocks via spy logger. Boundary tests at exactly 32KB and 32KB+1.
- All ACs Met: ✓ — All 10 acceptance criteria verified (see traceability below)

**AC Traceability:**

| AC  | Requirement                         | Test(s)                                                                                         | Status |
| --- | ----------------------------------- | ----------------------------------------------------------------------------------------------- | ------ |
| 1   | Base64 validation before FULFILL    | `validateIlpResponseData: pass through valid base64`, `PacketHandler: validate in FULFILL path` | ✓      |
| 2   | Invalid base64 omitted with warning | `validateIlpResponseData: return undefined and warn for invalid base64`                         | ✓      |
| 3   | Size validation ≤ 32KB              | `validateIlpResponseData: oversized data`, boundary tests (32KB exact, 32KB+1)                  | ✓      |
| 4   | Oversized data omitted with warning | `validateIlpResponseData: return undefined and warn for oversized data`                         | ✓      |
| 5   | Falsy values pass through           | `undefined data`, `null data`, `empty string data` tests                                        | ✓      |
| 6   | Validation applied to REJECT path   | `PacketHandler: validate in REJECT path`                                                        | ✓      |
| 7   | Pure testable utility function      | Exported `validateIlpResponseData(data, logger)` — correct signature                            | ✓      |
| 8   | Unit tests for all paths            | 8 validateIlpResponseData tests + 2 integration tests = 10 new tests                            | ✓      |
| 9   | No fulfillment computation change   | `computeFulfillmentFromData` on line 118 uses `request.data`, unchanged                         | ✓      |
| 10  | All existing tests pass             | 102/102 tests pass, zero regressions                                                            | ✓      |

### Improvements Checklist

All items handled — no outstanding actions for dev:

- [x] Valid base64 round-trip check implemented
- [x] 32KB size limit enforced with structured warning log
- [x] Both FULFILL and REJECT paths validated
- [x] Falsy short-circuit for null/undefined/empty
- [x] Existing tests updated to use valid base64 data
- [x] Boundary tests at 32KB and 32KB+1
- [x] Null safety test (runtime BLS may return null despite types)

### Security Review

No security concerns. The validation function is defensive-by-design:

- Prevents injection of malformed binary data into ILP packets
- Enforces the RFC-0027 32KB data limit that the connector enforces for PREPARE but was missing for FULFILL/REJECT
- `try/catch` around Buffer.from prevents any unexpected decode errors from crashing the packet handler
- Graceful degradation (omit data, log warning) is the correct choice — a validation failure shouldn't prevent payment fulfillment

### Performance Considerations

No concerns. The base64 decode + re-encode round-trip is O(n) where n is data size, bounded by the 32KB limit. This adds negligible overhead to the packet handling path — the BLS HTTP call dominates latency by orders of magnitude.

### Files Modified During Review

None — no refactoring was needed.

### Gate Status

Gate: PASS → docs/qa/gates/22.4-validate-bls-response-data-before-fulfill-pass-through.yml

### Recommended Status

✓ Ready for Done
