# Story 24.1: Accept ConnectorConfig Object in Constructor

## Status

Done

## Story

**As a** library consumer,
**I want** to instantiate `ConnectorNode` with a config object,
**so that** I can embed the connector in my process without needing a YAML file on disk.

## Acceptance Criteria

1. `new ConnectorNode(configObject, logger)` works without a file on disk
2. `new ConnectorNode('/path/to/config.yaml', logger)` still works (backward compatible)
3. Same validation logic applied to both paths — same error messages
4. Invalid config objects produce clear validation errors
5. `ConfigLoader.validateConfig()` exported for external use
6. All existing ConnectorNode tests pass unchanged
7. New tests cover object construction, validation, and error cases

## Tasks / Subtasks

- [x] Task 1: Extract validation logic into `ConfigLoader.validateConfig()` (AC: 3, 4, 5)
  - [x] 1.1 In `packages/connector/src/config/config-loader.ts`, add a new public static method `validateConfig(raw: unknown): ConnectorConfig`
  - [x] 1.2 Move the validation logic from `loadConfig()` (lines 117-153) into `validateConfig()`: `validateRequiredFields`, `validatePeers`, `validateRoutes`, `validatePorts`, `loadEnvironment`, `loadBlockchainConfig`, `loadExplorerConfig`, and final `ConnectorConfig` assembly. The existing private static helper methods (`validateRequiredFields`, `validatePeers`, etc.) remain `private static` — no visibility changes needed since `validateConfig` is on the same class.
  - [x] 1.3 Refactor `loadConfig(filePath)` to: read file, parse YAML, ensure object, then call `this.validateConfig(parsedYaml)` for validation
  - [x] 1.4 Ensure `validateConfig` throws `ConfigurationError` with the same error messages as before
  - [x] 1.5 Export `validateConfig` from `ConfigLoader` class (it's already a static method, so it's accessible via `ConfigLoader.validateConfig()`)
  - [x] 1.6 **Environment field handling**: `validateConfig()` always loads `environment` from `process.env.ENVIRONMENT` (defaulting to `'development'`), `blockchain` from `BASE_ENABLED`/`XRPL_ENABLED` env vars, and `explorer` from `EXPLORER_*` env vars — regardless of whether the caller's object includes these fields. These are process-level concerns, not config-file concerns. Any values for `environment`, `blockchain`, or `explorer` in the input object are **overridden** by env vars. Document this in the method's JSDoc.
  - [x] 1.7 **Optional field pass-through**: The current `loadConfig()` config assembly (lines 136-147) only passes through `healthCheckPort`, `logLevel`, and `dashboardTelemetryUrl` from the raw input. It **drops** these optional `ConnectorConfig` fields: `settlement`, `security`, `performance`, `adminApi`, `localDelivery`, `mode`, `firstHopUrl`, `btpAuthToken`. The new `validateConfig()` must pass through all optional fields from the input object. Add them to the config assembly (e.g., `settlement: rawConfig.settlement as SettlementConfig | undefined`, etc.).

- [x] Task 2: Modify `ConnectorNode` constructor to accept `ConnectorConfig | string` (AC: 1, 2)
  - [x] 2.1 Change constructor signature from `(configFilePath: string, logger: Logger)` to `(config: ConnectorConfig | string, logger: Logger)`
  - [x] 2.2 Add type check: if `typeof config === 'string'`, treat as file path and call `ConfigLoader.loadConfig(config)` (existing behavior)
  - [x] 2.3 If `config` is an object, call `ConfigLoader.validateConfig(config)` to validate and normalize
  - [x] 2.4 Adjust logging: when string, log `filePath`; when object, log `source: 'object'`
  - [x] 2.5 Update JSDoc on constructor from `@param configFilePath - Path to YAML configuration file` to `@param config - ConnectorConfig object or path to YAML configuration file`
  - [x] 2.6 All code after config resolution remains unchanged (routing table init, BTP init, etc.)

- [x] Task 3: Update `packages/connector/src/index.ts` exports (AC: 5)
  - [x] 3.1 Add `ConfigLoader` to the export block in `index.ts` (currently NOT exported — only `ConnectorNode`, `RoutingTable`, `PacketHandler`, `BTPServer`, `BTPClient`, `LocalDeliveryClient`, `createLogger` are exported)
  - [x] 3.2 Add `ConfigurationError` to the export block (currently imported from `config-loader.ts` but not re-exported)
  - [x] 3.3 Add `ConnectorConfig` as a type export: `export type { ConnectorConfig } from './config/types'` (currently only `LocalDeliveryConfig` is type-exported)

- [x] Task 4: Update existing `connector-node.test.ts` to ensure backward compatibility (AC: 6)
  - [x] 4.1 Run existing tests first to confirm baseline passes before any code changes
  - [x] 4.2 After refactoring, run existing tests to confirm they pass with the refactored constructor (string path still works via `ConfigLoader.loadConfig` mock)
  - [x] 4.3 No changes should be needed to existing tests — the string path is preserved

- [x] Task 5: Add unit tests for object-based construction (AC: 1, 3, 4, 7)
  - [x] 5.1 Add test: `ConnectorNode` constructed with valid `ConnectorConfig` object initializes successfully
  - [x] 5.2 Add test: `ConnectorNode` constructed with string path still calls `ConfigLoader.loadConfig` (backward compat)
  - [x] 5.3 Add test: Invalid config object (missing `nodeId`) throws `ConfigurationError`
  - [x] 5.4 Add test: Invalid config object (missing `peers`) throws `ConfigurationError`
  - [x] 5.5 Add test: Invalid config object (invalid port range) throws `ConfigurationError`
  - [x] 5.6 Add test: `ConfigLoader.validateConfig()` validates and returns a proper `ConnectorConfig`
  - [x] 5.7 Add test: `ConfigLoader.validateConfig()` throws on invalid input
  - [x] 5.8 Add test: `ConfigLoader.loadConfig()` still works unchanged (calls `validateConfig` internally)
  - [x] 5.9 Add `validateConfig()` tests at `packages/connector/test/unit/config-loader.test.ts` (existing ConfigLoader test location — use this for consistency)

- [x] Task 6: Verify TypeScript compilation across monorepo (AC: 6)
  - [x] 6.1 Run `npm run build` from monorepo root to verify no type errors
  - [x] 6.2 Verify no downstream compilation issues. Currently no source code imports from `@agent-runtime/connector` outside the connector package itself (only documentation references exist), so this is a quick verification pass.

## Dev Notes

### Epic Context

This is the first story in Epic 24 (Connector Library API — Brownfield Enhancement). The epic's goal is to refactor `ConnectorNode` to work as an embeddable library (not just a CLI-driven service). This story establishes the foundation by decoupling config loading from file I/O, enabling in-process composition.

### Relevant Source Tree

```
packages/connector/src/
├── core/
│   ├── connector-node.ts          # PRIMARY: Constructor modification target
│   └── connector-node.test.ts     # Existing tests (must remain passing)
├── config/
│   ├── config-loader.ts           # PRIMARY: Extract validateConfig() method
│   └── types.ts                   # ConnectorConfig type definition (no changes needed)
├── index.ts                       # Package exports (must add ConfigLoader, ConfigurationError, ConnectorConfig)
```

[Source: docs/architecture/source-tree.md]

### Current Constructor Implementation

The current `ConnectorNode` constructor at `packages/connector/src/core/connector-node.ts:71` takes `(configFilePath: string, logger: Logger)` and immediately calls `ConfigLoader.loadConfig(configFilePath)` which:

1. Reads file from disk (`fs.readFileSync`)
2. Parses YAML (`yaml.load`)
3. Validates required fields, peers, routes, ports (manual `if`-check validation throwing `ConfigurationError` — **not** Zod)
4. Loads environment, blockchain config, explorer config from env vars
5. Runs `validateEnvironment()` cross-validation
6. Returns assembled `ConnectorConfig`

[Source: packages/connector/src/config/config-loader.ts lines 86-153]

### ConfigLoader Validation Split

The `ConfigLoader.loadConfig()` method currently does two things:

1. **File I/O** (lines 87-114): Read file, parse YAML, basic object check
2. **Validation** (lines 117-153): Field validation (`validateRequiredFields`, `validatePeers`, `validateRoutes`, `validatePorts`), environment/blockchain/explorer loading from env vars, config assembly

The new `validateConfig(raw: unknown)` method should contain step 2 only. The `loadConfig()` method keeps step 1 and then calls `validateConfig()`.

**Important**: The `raw` parameter to `validateConfig` should be `unknown` (not `ConnectorConfig`) because the whole point is validating untrusted input. The method's return type is `ConnectorConfig` (validated).

The existing private static helper methods (`validateRequiredFields`, `validatePeers`, `validateRoutes`, `validatePorts`, `loadEnvironment`, `loadBlockchainConfig`, `loadExplorerConfig`) remain `private static` — no visibility changes needed since `validateConfig` is a `public static` method on the same class.

[Source: packages/connector/src/config/config-loader.ts]

### ConnectorConfig Type

The `ConnectorConfig` interface is defined in `packages/connector/src/config/types.ts:162`. Key required fields validated by `validateRequiredFields`:

- `nodeId: string`
- `btpServerPort: number`
- `peers: PeerConfig[]`
- `routes: RouteConfig[]`

Fields injected by `validateConfig()` from environment variables (always overridden, not taken from input object):

- `environment: Environment` — from `process.env.ENVIRONMENT`, defaults to `'development'`
- `blockchain?: BlockchainConfig` — from `BASE_ENABLED`, `XRPL_ENABLED`, and related env vars
- `explorer?: ExplorerConfig` — from `EXPLORER_*` env vars

**Design Decision**: The `environment` field is **required** on the `ConnectorConfig` interface (not optional). Since `validateConfig()` always injects it from env vars, this is satisfied regardless of whether the caller's input includes it. Library consumers passing a config object do **not** need to supply `environment`, `blockchain`, or `explorer` — these are always derived from the process environment. Any values the caller provides for these fields are silently overridden.

Optional fields (pass-through from input object): `healthCheckPort`, `logLevel`, `dashboardTelemetryUrl`, `settlement`, `security`, `performance`, `adminApi`, `localDelivery`, `mode`, `firstHopUrl`, `btpAuthToken`.

**Implementation Note — Config Assembly Gap**: The current `loadConfig()` config assembly at `config-loader.ts:136-147` only passes through `healthCheckPort`, `logLevel`, and `dashboardTelemetryUrl` from the raw input. The remaining optional fields (`settlement`, `security`, `performance`, `adminApi`, `localDelivery`, `mode`, `firstHopUrl`, `btpAuthToken`) are **silently dropped** because YAML config files historically don't include them. The new `validateConfig()` method must add these fields to the assembly so library consumers can pass a complete config object. See Task 1.7.

[Source: packages/connector/src/config/types.ts lines 162-351, config-loader.ts lines 136-147]

### Current Package Exports

The current `packages/connector/src/index.ts` exports:

```typescript
export {
  ConnectorNode,
  RoutingTable,
  PacketHandler,
  BTPServer,
  BTPClient,
  LocalDeliveryClient,
  createLogger,
};
export type { LocalDeliveryConfig } from './config/types';
```

**Not currently exported** (must be added by Task 3):

- `ConfigLoader` — needed for `ConfigLoader.validateConfig()` external use
- `ConfigurationError` — needed for callers to catch validation errors
- `ConnectorConfig` type — needed for callers to construct config objects

[Source: packages/connector/src/index.ts lines 1-32]

### Existing Test Patterns

Existing `connector-node.test.ts` mocks `ConfigLoader.loadConfig` via `jest.mock('../config/config-loader')` and then overrides it with `(ConfigLoader.loadConfig as jest.Mock) = jest.fn().mockReturnValue(config)`. This means existing tests construct `ConnectorNode` with a string path, and the mock returns a config object. These tests should continue to pass unchanged since the string-path code path is preserved.

For new tests with object construction, you should NOT mock `ConfigLoader.validateConfig` — instead, pass a real config object and let validation run (or mock only the specific validators if needed).

**Note**: Run existing tests before any code changes to confirm baseline passes (a recent fix `f874c1e` added a missing `isConnected` mock — verify this is in place).

[Source: packages/connector/src/core/connector-node.test.ts lines 1-100]

### Config Loader Test Files

Existing `ConfigLoader` tests are at:

- `packages/connector/test/unit/config-loader.test.ts` — **use this location for new `validateConfig()` tests** (consistency with existing tests)
- `packages/connector/test/unit/config-loader-mesh.test.ts`

[Source: test file glob results]

### CLI Entry Point

The CLI entry point at `packages/connector/src/index.ts:56` creates `ConnectorNode` with a file path: `new ConnectorNode(configFile, logger)`. This story does NOT modify the CLI — it remains using the file path. Epic 25 (CLI/Library Separation) will handle moving CLI concerns out.

[Source: packages/connector/src/index.ts lines 38-56]

### Downstream Consumers

No source code outside the connector package currently imports from `@agent-runtime/connector`. References to the package exist only in documentation files (epic PRDs, guides, API docs). Task 6.2 (downstream compilation check) is therefore a quick verification pass.

[Source: grep for `@agent-runtime/connector` imports across codebase]

### Coding Standards

- TypeScript strict mode, no `any` types except in test mocks [Source: docs/architecture/coding-standards.md]
- File naming: kebab-case (`config-loader.ts`) [Source: docs/architecture/coding-standards.md]
- Classes: PascalCase (`ConfigLoader`) [Source: docs/architecture/coding-standards.md]
- Use Pino logger exclusively (no `console.log`) [Source: docs/architecture/coding-standards.md]
- All async functions must handle errors with try-catch [Source: docs/architecture/coding-standards.md]

### Testing

- **Framework:** Jest 29.7.x with `ts-jest` [Source: docs/architecture/test-strategy-and-standards.md]
- **File Convention:** Co-located `<filename>.test.ts` next to source [Source: docs/architecture/test-strategy-and-standards.md]
- **Test Location:** New `validateConfig()` tests at `packages/connector/test/unit/config-loader.test.ts` (existing ConfigLoader test location)
- **Pattern:** AAA (Arrange, Act, Assert) with descriptive test names [Source: docs/architecture/test-strategy-and-standards.md]
- **Mocking:** Jest built-in (`jest.fn()`, `jest.mock()`) [Source: docs/architecture/test-strategy-and-standards.md]
- **Coverage Requirement:** >80% line coverage for connector package [Source: docs/architecture/test-strategy-and-standards.md]
- **Mock Isolation:** Create fresh mock instances in `beforeEach()`, use `mockResolvedValueOnce()` for sequential calls [Source: docs/architecture/test-strategy-and-standards.md#anti-pattern-3]
- **Resource Cleanup:** Use `afterEach()` to release all resources [Source: docs/architecture/test-strategy-and-standards.md#anti-pattern-5]

## Change Log

| Date       | Version | Description                                                                                                                                                                  | Author       |
| ---------- | ------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------ |
| 2026-02-10 | 1.0     | Initial story creation                                                                                                                                                       | Scrum Master |
| 2026-02-10 | 1.1     | Validation fixes: remove Zod reference, clarify env field handling, add export details, resolve test location, add downstream consumer info, add JSDoc update task           | Scrum Master |
| 2026-02-10 | 1.2     | Add Task 1.7: optional field pass-through in config assembly (settlement, security, performance, adminApi, localDelivery, mode, firstHopUrl, btpAuthToken currently dropped) | Scrum Master |

## Dev Agent Record

### Agent Model Used

Claude Opus 4.6

### Debug Log References

No debug issues encountered. All tasks completed on first attempt.

### Completion Notes List

- Extracted `ConfigLoader.validateConfig(raw: unknown): ConnectorConfig` as public static method
- `loadConfig()` refactored to call `validateConfig()` internally after file I/O
- `ConnectorNode` constructor now accepts `ConnectorConfig | string` with backward-compatible logging (`filePath` for strings, `source: 'object'` for objects)
- Added `ConfigLoader`, `ConfigurationError`, and `ConnectorConfig` type to package exports
- All 28 existing connector-node tests pass unchanged
- All 36 existing config-loader tests pass unchanged
- Added 6 new connector-node tests (object construction, error cases, logging)
- Added 7 new config-loader tests (validateConfig, optional field pass-through, env override)
- Full regression: 93 suites passed, 2156 tests passed, 0 failures
- TypeScript build passes across entire monorepo

### File List

- `packages/connector/src/config/config-loader.ts` — Added `validateConfig()` method, refactored `loadConfig()`, added imports for optional config types
- `packages/connector/src/core/connector-node.ts` — Changed constructor signature to `(config: ConnectorConfig | string, logger: Logger)`, updated JSDoc
- `packages/connector/src/index.ts` — Added `ConfigLoader`, `ConfigurationError` exports and `ConnectorConfig` type export
- `packages/connector/src/core/connector-node.test.ts` — Added 6 tests for object-based construction
- `packages/connector/test/unit/config-loader.test.ts` — Added 7 tests for `validateConfig()` and `loadConfig` internal delegation

## QA Results

### Review Date: 2026-02-11

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

Excellent implementation quality. The story cleanly extracts `validateConfig()` from `loadConfig()`, preserving all existing behavior while enabling object-based construction. The code follows established patterns in the codebase, uses proper TypeScript typing, and the diff is minimal and focused. The constructor refactoring in `ConnectorNode` is clean — the `typeof config === 'string'` branching is straightforward and the logging context correctly differentiates between file-path and object-based construction.

Key strengths:

- **Clean separation of concerns**: File I/O stays in `loadConfig()`, validation/normalization in `validateConfig()`
- **Backward compatibility preserved**: All 28 pre-existing connector-node tests pass unchanged, all 36 pre-existing config-loader tests pass unchanged
- **JSDoc quality**: `validateConfig()` has thorough documentation including the env-override behavior
- **Optional field pass-through**: All 8 optional fields (`settlement`, `security`, `performance`, `adminApi`, `localDelivery`, `mode`, `firstHopUrl`, `btpAuthToken`) are properly passed through, fixing the pre-existing gap where they were silently dropped

### Refactoring Performed

No refactoring performed during review — the implementation is clean and well-structured.

### Compliance Check

- Coding Standards: ✓ TypeScript strict mode, no `any` types in production code, kebab-case files, PascalCase classes, Pino logger used exclusively
- Project Structure: ✓ Files in correct locations, exports in index.ts properly organized
- Testing Strategy: ✓ Jest 29.x with ts-jest, AAA pattern, co-located tests for connector-node, existing `test/unit/` location for config-loader tests, mock isolation in `beforeEach`
- All ACs Met: ✓ All 7 acceptance criteria satisfied (see trace below)

### Improvements Checklist

- [x] `validateConfig()` extracted as public static method with `unknown` parameter type (AC 5)
- [x] `loadConfig()` refactored to delegate to `validateConfig()` (AC 3)
- [x] Constructor accepts `ConnectorConfig | string` union type (AC 1, 2)
- [x] Logging differentiates between file-path and object construction (AC 1, 2)
- [x] `ConfigLoader`, `ConfigurationError`, and `ConnectorConfig` type exported (AC 5)
- [x] 6 new connector-node tests for object construction path (AC 7)
- [x] 7 new config-loader tests for `validateConfig()` (AC 7)
- [x] All existing tests pass unchanged (AC 6)
- [x] TypeScript compiles without errors across monorepo (AC 6)
- [ ] Consider adding a test that exercises `validateConfig()` with `undefined` input (edge case, low priority)
- [ ] Consider adding a negative test for `security`/`performance` optional fields with wrong types (future hardening, not required by AC)

### Security Review

No security concerns. The implementation:

- Validates untrusted input with `unknown` parameter type
- Throws `ConfigurationError` for all invalid inputs (no silent failures)
- Environment-sensitive fields (`environment`, `blockchain`, `explorer`) are always derived from env vars, preventing injection via config objects
- No secrets are logged; auth tokens pass through validation without being exposed

### Performance Considerations

No performance concerns. The `validateConfig()` method adds negligible overhead — it runs the same validation that `loadConfig()` already performed. No additional I/O, no new dependencies.

### Files Modified During Review

None — no modifications were necessary.

### Gate Status

Gate: PASS → docs/qa/gates/24.1-accept-connectorconfig-object-in-constructor.yml
Risk profile: N/A (standard review, no elevated risk factors)
NFR assessment: N/A (all NFRs pass)

### Recommended Status

✓ Ready for Done
