# Story 20.1: Add `POST /ilp/send` Endpoint to Agent-Runtime

**Epic:** 20 - Bidirectional Agent-Runtime Middleware
**Story Number:** 20.1
**Status:** Done

## Story

**As a** BLS developer,
**I want** an HTTP endpoint on agent-runtime that lets me send outbound ILP packets,
**so that** my BLS can initiate communication with other peers (e.g., SPSP handshakes, peer announcements).

## Acceptance Criteria

1. `POST /ilp/send` endpoint registered on agent-runtime HTTP server
2. Request validation rejects invalid ILP addresses, negative amounts, non-base64 data, and data exceeding 64KB
3. Condition computed as SHA256(SHA256(data)) — matches fulfillment = SHA256(data)
4. Default timeoutMs is 30000 (30 seconds)
5. HTTP 200 returned for both fulfill and reject (distinguished by `fulfilled` boolean)
6. HTTP 408 returned on timeout
7. HTTP 400 returned on validation failure
8. Existing routes (`/ilp/packets`, `/health`) unaffected
9. Unit tests for condition computation, request validation, response mapping
10. OpenAPI/JSDoc for the endpoint
11. HTTP 503 returned when BTP sender is not connected

## Dev Notes

### Epic Context

Epic 20 transforms agent-runtime from a one-way inbound proxy into a bidirectional middleware. This story adds the HTTP endpoint; Story 20.2 adds the BTP client that actually injects packets into the connector. Story 20.3 extends the Admin API with settlement fields.

**Dependency Note:** This story defines the endpoint and all its logic (validation, condition computation, response mapping). It depends on Story 20.2 for the actual BTP client that sends the packet. During implementation, the BTP sender dependency should be injected via interface so the endpoint can be fully tested with a mock sender. The `POST /ilp/send` handler will call `sendPacket(prepare)` on an injected sender interface — Story 20.2 provides the real implementation.

### Previous Story Insights

Story 19.4 (Enable OrbStack for macOS Development) was infrastructure-only. No code patterns or technical decisions from 19.4 are directly relevant to this story.

### Architecture Decisions

**Fulfillment Computation (Simplified):** [Source: docs/UNIFIED-DEPLOYMENT-PLAN.md]

- Old STREAM-based: `fulfillment = HMAC-SHA256(key, data)` with shared secret
- New simplified: `fulfillment = SHA256(rawDataBytes)`, `condition = SHA256(fulfillment)`
- For `POST /ilp/send`: `condition = SHA256(SHA256(Buffer.from(request.data, 'base64')))`
- The receiver computes `fulfillment = SHA256(rawDataBytes)` and returns it; the connector verifies `SHA256(fulfillment) === condition`

**Bidirectional Flow:**

- Inbound (existing): Connector → `POST /ilp/packets` → agent-runtime → `POST /handle-payment` → BLS
- Outbound (new): BLS → `POST /ilp/send` → agent-runtime → BTP inject → Connector → ILP network

### Data Models

**ILP Packet Types** [Source: packages/shared/src/types/ilp.ts]

```typescript
enum PacketType {
  PREPARE = 12,
  FULFILL = 13,
  REJECT = 14,
}

interface ILPPreparePacket {
  type: PacketType.PREPARE;
  amount: bigint;
  destination: ILPAddress;
  executionCondition: Buffer; // 32-byte SHA-256 hash
  expiresAt: Date;
  data: Buffer;
}

interface ILPFulfillPacket {
  type: PacketType.FULFILL;
  fulfillment: Buffer; // 32-byte preimage
  data: Buffer;
}

interface ILPRejectPacket {
  type: PacketType.REJECT;
  code: ILPErrorCode; // e.g., 'F00', 'T04', 'R00'
  triggeredBy: ILPAddress;
  message: string;
  data: Buffer;
}
```

**ILP Error Codes** [Source: packages/shared/src/types/ilp.ts]

- F-prefix: Final errors (permanent failures)
- T-prefix: Temporary errors (retryable)
- R-prefix: Relative errors (protocol violations)
- Key codes: `F00_BAD_REQUEST`, `F02_UNREACHABLE`, `T00_INTERNAL_ERROR`, `T01_PEER_UNREACHABLE`, `R00_TRANSFER_TIMED_OUT`

**ILP Address Validation** [Source: packages/shared/src/types/ilp.ts]

- Function: `isValidILPAddress(address: string): boolean`
- Validates: alphanumeric + hyphen + underscore + dots, no leading/trailing dots, no consecutive dots, max 1023 chars
- Pattern: `/^[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)*$/`

### API Specifications

**New Types to Add** [Source: packages/agent-runtime/src/types/index.ts]

```typescript
// Request body for POST /ilp/send
interface IlpSendRequest {
  destination: string; // Valid ILP address (RFC-0015)
  amount: string; // Non-negative integer string (e.g., "0", "1500000")
  data: string; // Base64-encoded application data (max 64KB decoded)
  timeoutMs?: number; // Optional, default 30000 (30 seconds)
}

// Response body for POST /ilp/send
interface IlpSendResponse {
  fulfilled: boolean;
  fulfillment?: string; // Base64-encoded 32-byte preimage (when fulfilled=true)
  code?: string; // ILP error code (when fulfilled=false)
  message?: string; // Human-readable error (when fulfilled=false)
  data?: string; // Base64-encoded response data (optional in both cases)
}
```

**Sender Interface (for dependency injection)**

```typescript
// Interface that Story 20.2's OutboundBTPClient will implement
interface IPacketSender {
  sendPacket(prepare: ILPPreparePacket): Promise<ILPFulfillPacket | ILPRejectPacket>;
  isConnected(): boolean;
}
```

**HTTP Response Codes:**

- `200 OK`: Both FULFILL and REJECT responses (distinguished by `fulfilled` boolean)
- `400 Bad Request`: Validation failure (invalid ILP address, negative amount, non-base64 data)
- `408 Request Timeout`: No response within timeoutMs
- `503 Service Unavailable`: BTP client not connected (sender.isConnected() === false)

**Error Response Bodies:**

```typescript
// 400 Bad Request
{ error: 'Bad request', message: 'Invalid ILP address: ..invalid..address' }
{ error: 'Bad request', message: 'Amount must be a non-negative integer string' }
{ error: 'Bad request', message: 'Data must be valid base64' }
{ error: 'Bad request', message: 'timeoutMs must be a positive integer' }
{ error: 'Bad request', message: 'Missing required field: destination' }
{ error: 'Bad request', message: 'Data exceeds maximum size of 65536 bytes' }

// 408 Request Timeout
{ error: 'Request timeout', message: 'No response received within 30000ms' }

// 503 Service Unavailable
{ error: 'Service unavailable', message: 'Outbound sender not connected' }
```

### Existing HTTP Server Patterns

**Route Registration** [Source: packages/agent-runtime/src/http/http-server.ts]

- Framework: Express with `express.json()` middleware
- Pattern: `this.app.post('/path', async (req, res) => { ... })`
- Existing routes: `GET /health`, `GET /ready`, `POST /ilp/packets`, SPSP routes via `spspServer.getRouter()` (includes `/.well-known/pay`)
- **Note:** SPSP routes exist in the current codebase but are slated for removal in a later story per UNIFIED-DEPLOYMENT-PLAN. Their presence/removal is out-of-scope for this story.
- Error handler: `(err, req, res, next) => { ... }` at end of middleware chain
- Request logging middleware already in place

**Validation Pattern** [Source: packages/connector/src/http/admin-api.ts]

```typescript
if (!body.field || typeof body.field !== 'string') {
  res.status(400).json({ error: 'Bad request', message: 'Missing or invalid field' });
  return;
}
```

**HttpServer Constructor Change** [Source: packages/agent-runtime/src/http/http-server.ts, packages/agent-runtime/src/agent-runtime.ts]

- Current constructor signature: `HttpServer(config, spspServer, packetHandler, sessionManager, logger)`
- Add optional `sender?: IPacketSender` parameter after `logger`
- When `sender` is `null` or `undefined`, `POST /ilp/send` should return HTTP 503 with `{ error: 'Service unavailable', message: 'Outbound sender not configured' }`
- Story 20.2 will provide the real `IPacketSender` implementation

### Condition Computation Logic

Using Node.js crypto module [Source: docs/UNIFIED-DEPLOYMENT-PLAN.md, packages/agent-runtime/src/stream/fulfillment.ts]:

```typescript
import * as crypto from 'crypto';

function computeConditionFromData(data: Buffer): { condition: Buffer; fulfillment: Buffer } {
  const fulfillment = crypto.createHash('sha256').update(data).digest();
  const condition = crypto.createHash('sha256').update(fulfillment).digest();
  return { condition, fulfillment };
}
```

### ILP Prepare Packet Construction

```typescript
const preparePacket: ILPPreparePacket = {
  type: PacketType.PREPARE,
  amount: BigInt(request.amount),
  destination: request.destination as ILPAddress,
  executionCondition: condition, // 32-byte Buffer from computeConditionFromData
  expiresAt: new Date(Date.now() + timeoutMs),
  data: rawDataBytes, // Buffer.from(request.data, 'base64')
};
```

### Response Mapping

```typescript
// Map ILP response to HTTP response
if (response.type === PacketType.FULFILL) {
  res.status(200).json({
    fulfilled: true,
    fulfillment: response.fulfillment.toString('base64'),
    data: response.data.length > 0 ? response.data.toString('base64') : undefined,
  });
} else if (response.type === PacketType.REJECT) {
  res.status(200).json({
    fulfilled: false,
    code: response.code,
    message: response.message,
    data: response.data.length > 0 ? response.data.toString('base64') : undefined,
  });
}
```

### File Locations

Based on project structure [Source: docs/architecture/source-tree.md]:

| Action        | File Path                                                                                                                   |
| ------------- | --------------------------------------------------------------------------------------------------------------------------- |
| **Modify**    | `packages/agent-runtime/src/http/http-server.ts` — Add `POST /ilp/send` route                                               |
| **Modify**    | `packages/agent-runtime/src/types/index.ts` — Add `IlpSendRequest`, `IlpSendResponse`, `IPacketSender`                      |
| **Create**    | `packages/agent-runtime/src/http/ilp-send-handler.ts` — Handler logic (validation, condition computation, response mapping) |
| **Create**    | `packages/agent-runtime/src/http/ilp-send-handler.test.ts` — Unit tests co-located                                          |
| **Modify**    | `packages/agent-runtime/src/agent-runtime.ts` — Wire sender into HttpServer constructor                                     |
| **Reference** | `packages/shared/src/types/ilp.ts` — ILP types, `isValidILPAddress()`, `PacketType`                                         |
| **Reference** | `packages/agent-runtime/src/stream/fulfillment.ts` — Existing crypto pattern reference                                      |
| **Reference** | `tools/send-packet/src/btp-sender.ts` — BTP injection pattern (for Story 20.2, but useful reference)                        |

### Technical Constraints

- **No `any` types**: TypeScript strict mode enforced [Source: docs/architecture/coding-standards.md]
- **Pino logger only**: Never use `console.log` [Source: docs/architecture/coding-standards.md]
- **No hardcoded ports/URLs**: Use environment variables with defaults [Source: docs/architecture/coding-standards.md]
- **All async functions must handle errors**: Use try-catch [Source: docs/architecture/coding-standards.md]
- **File naming**: kebab-case (e.g., `ilp-send-handler.ts`) [Source: docs/architecture/coding-standards.md]
- **Class naming**: PascalCase (e.g., `IlpSendHandler`) [Source: docs/architecture/coding-standards.md]
- **Use Buffer for binary data**: Not Uint8Array [Source: docs/architecture/coding-standards.md]

### Testing

**Framework:** Jest 29.7.x with ts-jest [Source: docs/architecture/test-strategy-and-standards.md]

**File Convention:** Co-located `*.test.ts` next to source [Source: docs/architecture/coding-standards.md]

**Test Location:** `packages/agent-runtime/src/http/ilp-send-handler.test.ts`

**Coverage Requirement:** >80% line coverage for new handler code. Note: test-strategy-and-standards.md specifies >80% for connector and >90% for shared; agent-runtime has no explicit target but should follow the >80% baseline. [Source: docs/architecture/test-strategy-and-standards.md]

**Test Pattern:** AAA (Arrange, Act, Assert) with descriptive names [Source: docs/architecture/test-strategy-and-standards.md]

**Key Test Scenarios:**

1. **Condition Computation:**
   - Verify `condition === SHA256(SHA256(data))` for known test vectors
   - Verify `fulfillment === SHA256(data)` matches returned fulfillment

2. **Request Validation:**
   - Reject missing `destination` field → 400
   - Reject invalid ILP address (e.g., `..invalid..address`) → 400
   - Reject negative amount (e.g., `-100`) → 400
   - Reject non-integer amount (e.g., `12.5`) → 400
   - Reject non-base64 data → 400
   - Reject missing required fields → 400
   - Accept valid request with all fields
   - Accept request without optional `timeoutMs` (defaults to 30000)

3. **Response Mapping:**
   - FULFILL response → `{ fulfilled: true, fulfillment: "...", data?: "..." }`
   - REJECT response → `{ fulfilled: false, code: "F02", message: "...", data?: "..." }`
   - Both return HTTP 200

4. **Timeout Handling:**
   - Sender timeout → HTTP 408 response

5. **Sender Not Connected:**
   - `sender.isConnected() === false` → HTTP 503

6. **Existing Routes Unaffected:**
   - `GET /health` still works
   - `POST /ilp/packets` still works

**Mock Strategy:**

- Mock `IPacketSender` interface (not real BTP client)
- Mock `isValidILPAddress()` if needed, or use real implementation with known-good/bad addresses
- Create fresh mock instances in `beforeEach()` [Source: docs/architecture/test-strategy-and-standards.md, Anti-Pattern 3]
- Use `afterEach()` to clean up resources [Source: docs/architecture/test-strategy-and-standards.md, Anti-Pattern 5]

## Tasks / Subtasks

### 1. Define Types and Interfaces (AC: 1, 2)

- [x] Add `IlpSendRequest` interface to `packages/agent-runtime/src/types/index.ts`
  - Fields: `destination: string`, `amount: string`, `data: string`, `timeoutMs?: number`
- [x] Add `IlpSendResponse` interface to `packages/agent-runtime/src/types/index.ts`
  - Fields: `fulfilled: boolean`, `fulfillment?: string`, `code?: string`, `message?: string`, `data?: string`
- [x] Add `IPacketSender` interface to `packages/agent-runtime/src/types/index.ts`
  - Methods: `sendPacket(prepare: ILPPreparePacket): Promise<ILPFulfillPacket | ILPRejectPacket>`, `isConnected(): boolean`
- [x] Export all new types from the types module

### 2. Implement ILP Send Handler (AC: 1, 2, 3, 4, 5, 6, 7)

- [x] Create `packages/agent-runtime/src/http/ilp-send-handler.ts`
- [x] Implement request validation function:
  - [x] Validate `destination` is present and passes `isValidILPAddress()`
  - [x] Validate `amount` is a non-negative integer string (regex: `/^\d+$/`)
  - [x] Validate `data` is valid base64 (attempt `Buffer.from(data, 'base64')`, check round-trip)
  - [x] Validate decoded `data` does not exceed 65536 bytes (64KB) — return 400 if exceeded
  - [x] Validate `timeoutMs` is a positive integer if provided, default to 30000
  - [x] Return structured 400 error on any validation failure
- [x] Implement condition computation function:
  - [x] `fulfillment = SHA256(Buffer.from(data, 'base64'))`
  - [x] `condition = SHA256(fulfillment)`
  - [x] Use Node.js `crypto.createHash('sha256')`
- [x] Implement ILP PREPARE packet construction:
  - [x] Set `type: PacketType.PREPARE`
  - [x] Set `amount: BigInt(request.amount)`
  - [x] Set `destination` from validated request
  - [x] Set `executionCondition` from computed condition
  - [x] Set `expiresAt: new Date(Date.now() + timeoutMs)`
  - [x] Set `data` from decoded base64 bytes
- [x] Implement response mapping:
  - [x] FULFILL → `{ fulfilled: true, fulfillment: base64, data?: base64 }`
  - [x] REJECT → `{ fulfilled: false, code, message, data?: base64 }`
- [x] Implement timeout handling → HTTP 408 response
- [x] Implement sender-not-connected check → HTTP 503 response
- [x] Add Pino logging for request receipt, success, failure, and timeout events

### 3. Register Route in HTTP Server (AC: 1, 8)

- [x] Add `POST /ilp/send` route to `packages/agent-runtime/src/http/http-server.ts`
- [x] Wire handler to receive injected `IPacketSender` dependency
- [x] Verify existing routes (`/health`, `/ready`, `/ilp/packets`) are unaffected (SPSP routes are mounted separately via `spspServer.getRouter()` and are out-of-scope)
- [x] Ensure route is registered before the 404 and error handler middleware

### 4. Wire Into Agent-Runtime Initialization (AC: 1)

- [x] Update `packages/agent-runtime/src/agent-runtime.ts` to accept optional `IPacketSender`
- [x] Pass sender to `HttpServer` constructor
- [x] For now, use `null` or a stub sender (real implementation comes in Story 20.2)
- [x] Ensure start/stop lifecycle is unaffected

### 5. Write Unit Tests (AC: 9)

- [x] Create `packages/agent-runtime/src/http/ilp-send-handler.test.ts`
- [x] **Condition computation tests:**
  - [x] Known test vector: verify SHA256(SHA256(data)) output
  - [x] Empty data produces valid 32-byte condition
  - [x] Different data produces different conditions
- [x] **Request validation tests:**
  - [x] Missing destination → 400
  - [x] Invalid ILP address → 400
  - [x] Negative amount → 400
  - [x] Float amount → 400
  - [x] Empty string amount → 400
  - [x] Non-base64 data → 400
  - [x] Missing data field → 400
  - [x] Data exceeding 64KB decoded → 400
  - [x] Valid request passes validation
  - [x] Optional timeoutMs defaults to 30000
  - [x] Negative timeoutMs → 400
- [x] **Response mapping tests:**
  - [x] FULFILL response mapped correctly with base64 fields
  - [x] REJECT response mapped correctly with code and message
  - [x] Empty data buffers omit data field from response
- [x] **Timeout test:**
  - [x] Mock sender that never resolves → verify 408 response
- [x] **Sender not connected test:**
  - [x] Mock sender.isConnected() returns false → verify 503 response
- [x] **Integration with existing routes:**
  - [x] Verify /health still responds 200
- [x] Follow AAA pattern with descriptive test names
- [x] Use fresh mock instances in `beforeEach()`
- [x] Clean up resources in `afterEach()`

### 6. Add JSDoc/OpenAPI Documentation (AC: 10)

- [x] Add JSDoc comments to `IlpSendRequest` and `IlpSendResponse` interfaces
- [x] Add JSDoc to the handler function describing endpoint behavior
- [x] Document request/response schemas with `@example` tags
- [x] Document error codes and when they occur

## Change Log

| Date       | Version | Description                                                                                                                                                                                                           | Author                |
| ---------- | ------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------- |
| 2026-02-08 | 1.0     | Initial story draft created from Epic 20                                                                                                                                                                              | Claude (SM)           |
| 2026-02-08 | 1.1     | Validation fixes: added AC #11 (503), clarified SPSP scope, documented HttpServer constructor change, added error response body examples, added 64KB data size limit, fixed coverage target, added QA Results section | Claude (Validation)   |
| 2026-02-08 | 1.2     | Implementation complete: all tasks done, 38 tests passing, 98.66% handler coverage                                                                                                                                    | Claude Opus 4.6 (Dev) |

## Dev Agent Record

### Agent Model Used

Claude Opus 4.6 (claude-opus-4-6)

### Debug Log References

No debug issues encountered. All tests passed on first full run.

### Completion Notes

- All 6 tasks completed successfully
- 38 new unit tests, all passing (73 total in agent-runtime package)
- Handler coverage: 98.66% statements, 97.14% branches, 100% functions
- TypeScript compiles cleanly with strict mode
- ESLint passes with no warnings
- Existing tests (fulfillment, session-manager) unaffected
- `POST /ilp/send` returns 503 by default (no sender configured until Story 20.2)
- Timeout cleanup implemented with `Promise.race` + `clearTimeout` in `.finally()` to prevent timer leaks
- Added `supertest` and `@types/supertest` as devDependencies for HTTP integration tests

### File List

| Action       | File                                                                                                                                                            |
| ------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Modified** | `packages/agent-runtime/src/types/index.ts` — Added `IlpSendRequest`, `IlpSendResponse`, `IPacketSender` interfaces with JSDoc                                  |
| **Created**  | `packages/agent-runtime/src/http/ilp-send-handler.ts` — Handler with validation, condition computation, packet construction, response mapping, timeout, logging |
| **Created**  | `packages/agent-runtime/src/http/ilp-send-handler.test.ts` — 38 unit tests covering all acceptance criteria                                                     |
| **Modified** | `packages/agent-runtime/src/http/http-server.ts` — Added `POST /ilp/send` route, optional `sender` constructor param                                            |
| **Modified** | `packages/agent-runtime/src/agent-runtime.ts` — Added optional `IPacketSender` constructor param, passed to HttpServer                                          |
| **Modified** | `packages/agent-runtime/src/index.ts` — Exported new types (`IlpSendRequest`, `IlpSendResponse`, `IPacketSender`)                                               |
| **Modified** | `packages/agent-runtime/package.json` — Added `supertest` and `@types/supertest` devDependencies                                                                |

## QA Results

### Review Date: 2026-02-08

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

Excellent implementation. The handler follows clean separation of concerns with a standalone `IlpSendHandler` class, pure validation function, and pure condition-computation function — all highly testable. Dependency injection via the `IPacketSender` interface is well-designed and allows full mock coverage. The timer cleanup pattern using `Promise.race` + `.finally()` is correct and prevents resource leaks. All 11 acceptance criteria are met. Code is clean, well-documented with JSDoc, and follows all project conventions.

### Refactoring Performed

None required. The implementation is well-structured and follows project patterns correctly.

### Compliance Check

- Coding Standards: ✓ — kebab-case files, PascalCase classes, camelCase methods, `_` private prefix, Pino logger, Buffer for binary data, strict TypeScript (no `any`), all async functions error-handled
- Project Structure: ✓ — handler co-located with HTTP server code, tests co-located with source, types in `types/index.ts`
- Testing Strategy: ✓ — AAA pattern, fresh mocks in `beforeEach()`, timer cleanup in `afterEach()`, descriptive test names, 98.66% handler coverage (exceeds >80% baseline)
- All ACs Met: ✓ — All 11 acceptance criteria verified (see traceability matrix below)

### AC Traceability

| AC  | Requirement                                    | Evidence                                                       |
| --- | ---------------------------------------------- | -------------------------------------------------------------- |
| 1   | `POST /ilp/send` registered                    | `http-server.ts:122` + supertest integration tests             |
| 2   | Validation rejects invalid inputs              | 16 validation unit tests + 2 HTTP integration tests            |
| 3   | Condition = SHA256(SHA256(data))               | 4 condition computation tests with known vectors               |
| 4   | Default timeout 30000ms                        | `DEFAULT_TIMEOUT_MS` constant + expiry verification test       |
| 5   | HTTP 200 for fulfill and reject                | FULFILL and REJECT response mapping tests (4 tests)            |
| 6   | HTTP 408 on timeout                            | Timeout test with short timeoutMs                              |
| 7   | HTTP 400 on validation failure                 | HTTP integration validation tests                              |
| 8   | Existing routes unaffected                     | Full suite passes (73/73), routes unchanged                    |
| 9   | Unit tests for condition, validation, response | 38 tests across all three areas                                |
| 10  | OpenAPI/JSDoc                                  | JSDoc on all interfaces, handler class, and exported functions |
| 11  | HTTP 503 when not connected                    | Two 503 tests (null sender + disconnected sender)              |

### Improvements Checklist

- [x] All validation edge cases covered (boundary 64KB, zero amount, empty base64)
- [x] Timer cleanup prevents resource leaks
- [x] Error responses follow existing project pattern (`{ error, message }`)
- [x] Pino logging covers all code paths (info, warn, error, debug)
- [ ] Consider adding `/ilp/send` health integration test in full HttpServer test suite (low priority — currently tested in isolation)
- [ ] Root `jest.config.js` missing `packages/agent-runtime` in `projects` array — tests only runnable from package dir (pre-existing, out of scope)

### Security Review

No concerns. Input validation is thorough — ILP address regex, amount format regex, base64 round-trip verification, 64KB size limit. Error messages for invalid ILP addresses are safe (ILP addresses are alphanumeric only after validation). No authentication is needed on this endpoint per architecture (BLS-to-agent-runtime is a local/internal call).

### Performance Considerations

No concerns. `Promise.race` timeout pattern is efficient. Timer cleanup in `.finally()` prevents accumulation. Condition computation uses Node.js native `crypto` module (fast). No unnecessary allocations in the request path.

### Files Modified During Review

None — no refactoring was needed.

### Gate Status

Gate: PASS → docs/qa/gates/20.1-add-post-ilp-send-endpoint.yml

### Recommended Status

✓ Ready for Done — All acceptance criteria met, 38 tests passing at 98.66% coverage, clean code quality, no security or performance concerns.
