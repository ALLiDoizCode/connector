import { finalizeEvent } from 'nostr-tools';
import {
  SignedClaim,
  ClaimRequest,
  NostrClaimEvent,
  EVMSignedClaim,
  XRPSignedClaim,
  AptosSignedClaim,
  EVMClaimRequest,
  XRPClaimRequest,
  AptosClaimRequest,
  CLAIM_TAG,
  CLAIM_EVENT_EVM,
  CLAIM_EVENT_XRP,
  CLAIM_EVENT_APTOS,
  isEVMSignedClaim,
  isXRPSignedClaim,
  isAptosSignedClaim,
} from '@m2m/shared';

/**
 * Convert hex string to Uint8Array
 */
function hexToBytes(hex: string): Uint8Array {
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < hex.length; i += 2) {
    bytes[i / 2] = parseInt(hex.substring(i, i + 2), 16);
  }
  return bytes;
}

/**
 * Type guard for EVM claim request
 */
function isEVMClaimRequest(request: ClaimRequest): request is EVMClaimRequest {
  return request.chain === 'evm';
}

/**
 * Type guard for XRP claim request
 */
function isXRPClaimRequest(request: ClaimRequest): request is XRPClaimRequest {
  return request.chain === 'xrp';
}

/**
 * Type guard for Aptos claim request
 */
function isAptosClaimRequest(request: ClaimRequest): request is AptosClaimRequest {
  return request.chain === 'aptos';
}

/**
 * ClaimEventBuilder - Constructs Nostr claim events wrapping content with signed claims
 *
 * This builder wraps message content (text or nested events) in Nostr claim events
 * following the Epic 30 Balance Proof Exchange protocol. Signed claims must be
 * generated by existing chain-specific signers before being passed to this builder.
 *
 * Integration with existing signers:
 * - EVM: PaymentChannelSDK.signBalanceProof() (Epic 8)
 * - XRP: ClaimSigner.signClaim() (Epic 9)
 * - Aptos: AptosClaimSigner.signClaim() (Epic 27)
 *
 * @example
 * ```typescript
 * const builder = new ClaimEventBuilder(privateKeyHex);
 * const evmClaim = await paymentChannelSDK.signBalanceProof(...);
 * const claimEvent = builder.wrapContent("Payment received", evmClaim, []);
 * ```
 */
export class ClaimEventBuilder {
  private readonly privateKeyBytes: Uint8Array;

  /**
   * @param privateKey - Hex-encoded Nostr private key (64 characters) for signing events
   */
  constructor(privateKey: string) {
    if (privateKey.length !== 64) {
      throw new Error(
        `Invalid private key length: expected 64 hex characters, got ${privateKey.length}`
      );
    }
    this.privateKeyBytes = hexToBytes(privateKey);
  }

  /**
   * Build tags array from signed claim and unsigned requests
   *
   * @param signedClaim - Signed claim data (pre-signed by chain-specific signer)
   * @param unsignedRequests - Array of unsigned claim requests for counterparty
   * @returns Array of Nostr event tags
   */
  private buildTags(signedClaim: SignedClaim, unsignedRequests: ClaimRequest[]): string[][] {
    const tags: string[][] = [];

    // Add chain-specific signed claim tags
    if (isEVMSignedClaim(signedClaim)) {
      tags.push(
        [CLAIM_TAG.IDENTIFIER, signedClaim.channelId], // 'd' tag for replaceable event
        [CLAIM_TAG.CHAIN, 'evm'],
        [CLAIM_TAG.CHANNEL, signedClaim.channelId],
        [CLAIM_TAG.AMOUNT, signedClaim.transferredAmount.toString()],
        [CLAIM_TAG.NONCE, signedClaim.nonce.toString()],
        [CLAIM_TAG.LOCKED, signedClaim.lockedAmount.toString()],
        [CLAIM_TAG.LOCKS_ROOT, signedClaim.locksRoot],
        [CLAIM_TAG.SIGNATURE, signedClaim.signature],
        [CLAIM_TAG.SIGNER, signedClaim.signer]
      );
    } else if (isXRPSignedClaim(signedClaim)) {
      // XRP does NOT have nonce
      tags.push(
        [CLAIM_TAG.IDENTIFIER, signedClaim.channelId],
        [CLAIM_TAG.CHAIN, 'xrp'],
        [CLAIM_TAG.CHANNEL, signedClaim.channelId],
        [CLAIM_TAG.AMOUNT, signedClaim.amount.toString()],
        [CLAIM_TAG.SIGNATURE, signedClaim.signature],
        [CLAIM_TAG.SIGNER, signedClaim.signer]
      );
    } else if (isAptosSignedClaim(signedClaim)) {
      tags.push(
        [CLAIM_TAG.IDENTIFIER, signedClaim.channelOwner], // 'd' tag uses owner address
        [CLAIM_TAG.CHAIN, 'aptos'],
        [CLAIM_TAG.CHANNEL, signedClaim.channelOwner],
        [CLAIM_TAG.AMOUNT, signedClaim.amount.toString()],
        [CLAIM_TAG.NONCE, signedClaim.nonce.toString()],
        [CLAIM_TAG.SIGNATURE, signedClaim.signature],
        [CLAIM_TAG.SIGNER, signedClaim.signer]
      );
    }

    // Add unsigned request tags
    for (const request of unsignedRequests) {
      if (isEVMClaimRequest(request)) {
        tags.push(
          [CLAIM_TAG.REQUEST_CHAIN, 'evm'],
          [CLAIM_TAG.REQUEST_CHANNEL, request.channelId],
          [CLAIM_TAG.REQUEST_AMOUNT, request.amount.toString()],
          [CLAIM_TAG.REQUEST_NONCE, request.nonce.toString()]
        );
      } else if (isXRPClaimRequest(request)) {
        // XRP does NOT have nonce
        tags.push(
          [CLAIM_TAG.REQUEST_CHAIN, 'xrp'],
          [CLAIM_TAG.REQUEST_CHANNEL, request.channelId],
          [CLAIM_TAG.REQUEST_AMOUNT, request.amount.toString()]
        );
      } else if (isAptosClaimRequest(request)) {
        tags.push(
          [CLAIM_TAG.REQUEST_CHAIN, 'aptos'],
          [CLAIM_TAG.REQUEST_CHANNEL, request.channelOwner],
          [CLAIM_TAG.REQUEST_AMOUNT, request.amount.toString()],
          [CLAIM_TAG.REQUEST_NONCE, request.nonce.toString()]
        );
      }
    }

    return tags;
  }

  /**
   * Wrap content with EVM signed claim (Kind 30001)
   *
   * @param content - Message text or serialized nested event
   * @param signedClaim - EVM signed claim from PaymentChannelSDK.signBalanceProof()
   * @param unsignedRequests - Unsigned claim requests for counterparty
   * @returns Signed Nostr claim event
   */
  wrapWithEVMClaim(
    content: string,
    signedClaim: EVMSignedClaim,
    unsignedRequests: ClaimRequest[]
  ): NostrClaimEvent {
    const tags = this.buildTags(signedClaim, unsignedRequests);

    const unsignedEvent = {
      kind: CLAIM_EVENT_EVM,
      created_at: Math.floor(Date.now() / 1000),
      content,
      tags,
    };

    const signedEvent = finalizeEvent(unsignedEvent, this.privateKeyBytes);

    return {
      ...signedEvent,
      kind: CLAIM_EVENT_EVM,
    };
  }

  /**
   * Wrap content with XRP signed claim (Kind 30002)
   *
   * Note: XRP payment channels do NOT use nonces. The amount field is cumulative
   * and must increase monotonically.
   *
   * @param content - Message text or serialized nested event
   * @param signedClaim - XRP signed claim from ClaimSigner.signClaim()
   * @param unsignedRequests - Unsigned claim requests for counterparty
   * @returns Signed Nostr claim event
   */
  wrapWithXRPClaim(
    content: string,
    signedClaim: XRPSignedClaim,
    unsignedRequests: ClaimRequest[]
  ): NostrClaimEvent {
    const tags = this.buildTags(signedClaim, unsignedRequests);

    const unsignedEvent = {
      kind: CLAIM_EVENT_XRP,
      created_at: Math.floor(Date.now() / 1000),
      content,
      tags,
    };

    const signedEvent = finalizeEvent(unsignedEvent, this.privateKeyBytes);

    return {
      ...signedEvent,
      kind: CLAIM_EVENT_XRP,
    };
  }

  /**
   * Wrap content with Aptos signed claim (Kind 30003)
   *
   * @param content - Message text or serialized nested event
   * @param signedClaim - Aptos signed claim from AptosClaimSigner.signClaim()
   * @param unsignedRequests - Unsigned claim requests for counterparty
   * @returns Signed Nostr claim event
   */
  wrapWithAptosClaim(
    content: string,
    signedClaim: AptosSignedClaim,
    unsignedRequests: ClaimRequest[]
  ): NostrClaimEvent {
    const tags = this.buildTags(signedClaim, unsignedRequests);

    const unsignedEvent = {
      kind: CLAIM_EVENT_APTOS,
      created_at: Math.floor(Date.now() / 1000),
      content,
      tags,
    };

    const signedEvent = finalizeEvent(unsignedEvent, this.privateKeyBytes);

    return {
      ...signedEvent,
      kind: CLAIM_EVENT_APTOS,
    };
  }

  /**
   * Wrap content with signed claim (dispatches to chain-specific method)
   *
   * This is the main entry point for wrapping content with any chain type.
   * The method automatically dispatches to the correct chain-specific builder
   * based on the claim's chain discriminator.
   *
   * @param content - Message text or serialized nested event
   * @param signedClaim - Pre-signed claim from chain-specific signer
   * @param unsignedRequests - Unsigned claim requests for counterparty
   * @returns Signed Nostr claim event
   */
  wrapContent(
    content: string,
    signedClaim: SignedClaim,
    unsignedRequests: ClaimRequest[]
  ): NostrClaimEvent {
    if (isEVMSignedClaim(signedClaim)) {
      return this.wrapWithEVMClaim(content, signedClaim, unsignedRequests);
    } else if (isXRPSignedClaim(signedClaim)) {
      return this.wrapWithXRPClaim(content, signedClaim, unsignedRequests);
    } else if (isAptosSignedClaim(signedClaim)) {
      return this.wrapWithAptosClaim(content, signedClaim, unsignedRequests);
    }

    // This should never happen due to TypeScript's exhaustiveness checking
    throw new Error(`Unknown claim chain: ${(signedClaim as SignedClaim).chain}`);
  }

  /**
   * Wrap a nested Nostr event with signed claim
   *
   * This method is used for FULFILL responses where the content is another
   * Nostr event rather than plain text. The nested event is JSON-serialized
   * and stored in the content field.
   *
   * @param nestedEvent - Nostr event to nest in content field
   * @param signedClaim - Pre-signed claim from chain-specific signer
   * @param unsignedRequests - Unsigned claim requests for counterparty
   * @returns Signed Nostr claim event with nested event in content
   */
  wrapNestedEvent(
    nestedEvent: import('./toon-codec').NostrEvent,
    signedClaim: SignedClaim,
    unsignedRequests: ClaimRequest[]
  ): NostrClaimEvent {
    const contentJson = JSON.stringify(nestedEvent);
    return this.wrapContent(contentJson, signedClaim, unsignedRequests);
  }
}
