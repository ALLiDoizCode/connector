/**
 * Deterministic Account ID Generator for TigerBeetle
 *
 * This module provides deterministic account ID generation using SHA-256 hashing.
 * Deterministic IDs enable several critical features:
 *
 * 1. **Idempotency**: createPeerAccounts can be called multiple times safely
 * 2. **No Database Lookups**: No need to query TigerBeetle to check if accounts exist
 * 3. **Stateless Creation**: Account IDs can be regenerated on demand without storage
 * 4. **Safe Retries**: Network failures or restarts can retry account creation without duplicates
 * 5. **Reduced Complexity**: No separate account ID mapping table needed
 *
 * Account IDs are generated by:
 * - Concatenating: nodeId | peerId | tokenId | accountType
 * - Hashing with SHA-256 (256-bit output)
 * - Taking first 128 bits (TigerBeetle requires 128-bit account IDs)
 * - Converting to bigint
 *
 * Hash collision risk: SHA-256 provides ~2^128 unique IDs (128-bit space).
 * Collision probability is negligible for expected peer counts (<10,000 peers).
 *
 * @module settlement/account-id-generator
 */

import { createHash } from 'crypto';
import { AccountType } from './types';

/**
 * Generates a deterministic 128-bit TigerBeetle account ID from input parameters.
 *
 * This function uses SHA-256 hashing to create reproducible account IDs that:
 * - Are guaranteed to be the same for identical inputs (determinism)
 * - Are extremely unlikely to collide for different inputs (cryptographic security)
 * - Are non-zero (TigerBeetle requirement)
 * - Enable idempotent account creation without database lookups
 *
 * The algorithm:
 * 1. Concatenate inputs with '|' separator: `${nodeId}|${peerId}|${tokenId}|${accountType}`
 * 2. Hash using SHA-256 to produce 256-bit hash
 * 3. Take first 128 bits (16 bytes) for TigerBeetle account ID
 * 4. Convert to bigint (unsigned 128-bit integer)
 * 5. Validate non-zero (if zero, rehash with salt and retry)
 *
 * @param nodeId - Our connector node ID (e.g., "connector-a")
 * @param peerId - Peer connector ID (e.g., "connector-b")
 * @param tokenId - Token identifier (e.g., "USD", "ETH")
 * @param accountType - Account type (DEBIT or CREDIT)
 * @returns Deterministic 128-bit account ID as bigint
 *
 * @example
 * const debitAccountId = generateAccountId(
 *   'connector-a',
 *   'connector-b',
 *   'USD',
 *   AccountType.DEBIT
 * );
 * // Returns: 123456789012345678901234567890n (example bigint)
 *
 * // Calling again with same inputs returns identical ID (idempotent)
 * const sameId = generateAccountId(
 *   'connector-a',
 *   'connector-b',
 *   'USD',
 *   AccountType.DEBIT
 * );
 * // debitAccountId === sameId (guaranteed)
 *
 * @example
 * // Different account type produces different ID
 * const creditAccountId = generateAccountId(
 *   'connector-a',
 *   'connector-b',
 *   'USD',
 *   AccountType.CREDIT
 * );
 * // creditAccountId !== debitAccountId (guaranteed different)
 */
export function generateAccountId(
  nodeId: string,
  peerId: string,
  tokenId: string,
  accountType: AccountType
): bigint {
  // Concatenate inputs with separator to create unique string
  // Format: nodeId|peerId|tokenId|accountType
  const concatenated = `${nodeId}|${peerId}|${tokenId}|${accountType}`;

  // Hash using SHA-256 to produce deterministic 256-bit hash
  const hash = createHash('sha256').update(concatenated).digest();

  // Extract first 16 bytes (128 bits) for TigerBeetle account ID
  // TigerBeetle uses 128-bit unsigned integers for account IDs
  const id128Bits = hash.subarray(0, 16);

  // Convert bytes to hexadecimal string, then to bigint
  // BigInt constructor accepts '0x' prefixed hex strings
  const accountId = BigInt('0x' + id128Bits.toString('hex'));

  // Validate non-zero (TigerBeetle rejects account ID 0)
  if (accountId === 0n) {
    // Extremely unlikely (probability ~1 in 2^128), but handle gracefully
    // Rehash with salt to produce non-zero ID
    return generateAccountIdWithSalt(nodeId, peerId, tokenId, accountType, 1);
  }

  return accountId;
}

/**
 * Generates account ID with salt for zero-collision edge case.
 *
 * This function is called if the primary hash produces a zero ID (astronomically unlikely).
 * It adds a numeric salt to the input and rehashes until a non-zero ID is produced.
 *
 * @param nodeId - Our connector node ID
 * @param peerId - Peer connector ID
 * @param tokenId - Token identifier
 * @param accountType - Account type (DEBIT or CREDIT)
 * @param salt - Numeric salt to add to input (starts at 1, increments on retry)
 * @returns Non-zero account ID as bigint
 *
 * @internal
 */
function generateAccountIdWithSalt(
  nodeId: string,
  peerId: string,
  tokenId: string,
  accountType: AccountType,
  salt: number
): bigint {
  // Add salt to input to produce different hash
  const concatenated = `${nodeId}|${peerId}|${tokenId}|${accountType}|${salt}`;

  // Hash with salt
  const hash = createHash('sha256').update(concatenated).digest();

  // Extract first 128 bits
  const id128Bits = hash.subarray(0, 16);

  // Convert to bigint
  const accountId = BigInt('0x' + id128Bits.toString('hex'));

  // Recursive retry with incremented salt if still zero (virtually impossible)
  if (accountId === 0n) {
    return generateAccountIdWithSalt(nodeId, peerId, tokenId, accountType, salt + 1);
  }

  return accountId;
}

/**
 * Validates that an account ID is valid for TigerBeetle.
 *
 * TigerBeetle account ID requirements:
 * - Must be a bigint (128-bit unsigned integer)
 * - Must be non-zero (0n is rejected by TigerBeetle)
 *
 * @param accountId - Account ID to validate
 * @returns True if valid, false otherwise
 *
 * @example
 * isValidAccountId(123456789n);  // true
 * isValidAccountId(0n);          // false
 */
export function isValidAccountId(accountId: bigint): boolean {
  // Check type is bigint
  if (typeof accountId !== 'bigint') {
    return false;
  }

  // Check non-zero
  if (accountId === 0n) {
    return false;
  }

  // Check non-negative (TigerBeetle uses unsigned integers)
  if (accountId < 0n) {
    return false;
  }

  return true;
}
